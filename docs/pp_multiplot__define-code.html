<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue May 16 12:42:26 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pp_multiplot__define.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pp_multiplot__define.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst rst'</span>
<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">;    pp_multiplot objects hold a grid of plots (from the plot function, of IDL</span>
<span class="comments">;    Graphics, not the plot procedure from direct graphics) with no empty space between lines</span>
<span class="comments">;    and columns, to use a single vertical/horizontal axis for each line/column</span>
<span class="comments">;    of plots. This was inspired by the functionality provided by `multiplot` from IDLAstro</span>
<span class="comments">;    (`http://idlastro.gsfc.nasa.gov/ftp/pro/plot/multiplot.pro &lt;http://idlastro.gsfc.nasa.gov/ftp/pro/plot/multiplot.pro>`)</span>
<span class="comments">;    for direct graphics.</span>
<span class="comments">;    </span>
<span class="comments">;    But contrary to multiplot, this system works for Graphics (instead of direct</span>
<span class="comments">;    graphics), allows for lines/columns of different heights/widths,</span>
<span class="comments">;    provides global margins and axes titles, and provides a synchronization</span>
<span class="comments">;    mechanism to keep the plots in the same line/column (or all) with the same</span>
<span class="comments">;    axes ranges and properties. Also, like in `pp_plot`, there is the option</span>
<span class="comments">;    of suppressing the first/last tick marks of the axes, to avoid their overlap</span>
<span class="comments">;    with the neighboring plots (enabled by default, depending on the plot's</span>
<span class="comments">;    location on the grid).</span>
<span class="comments">;    </span>
<span class="comments">;    A pp_multiplot object makes a window to hold the grid, and will contain all the</span>
<span class="comments">;    plots in the grid (made with the plot method provided here). The individual</span>
<span class="comments">;    plot objects can be retrieved (for instance, to set/get their properties),</span>
<span class="comments">;    and axes properties can be set (and synchronized) for entire lines/columns</span>
<span class="comments">;    (or all plots in the grid) at a time. The init/get/set methods pass any</span>
<span class="comments">;    extra properties to the window that contains the plot - the window class is</span>
<span class="comments">;    used here, not inherited.</span>
<span class="comments">;</span>
<span class="comments">;    See the documentation on the public methods</span>
<span class="comments">;    `pp_multiplot::init`, `pp_multiplot::plot`, `pp_multiplot::image`, </span>
<span class="comments">;    `pp_multiplot::contour`, `pp_multiplot::getproperty`,</span>
<span class="comments">;    `pp_multiplot::setproperty`, `pp_multiplot::sync_axes`, ,`pp_multiplot::close`,</span>
<span class="comments">;    `pp_multiplot::save`, and `pp_multiplot::getposition`, for details on their use.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Make a simple 2x2 grid with equal sizes::</span>
<span class="comments">;</span>
<span class="comments">;      m=pp_multiplot(multi_layout=[2,2],global_xtitle='Test X axis title',global_ytitle='Test Y axis title')</span>
<span class="comments">;      </span>
<span class="comments">;    Now populate the grid with plots using plot()'s test data::</span>
<span class="comments">;    </span>
<span class="comments">;      ;Since multi_index was not provided, this will occupy the first free location in the grid:</span>
<span class="comments">;      p0=m.plot(/test,color='red',thick=2.)</span>
<span class="comments">;      p1=m.plot(/test,color='blue',linestyle=1) ;Second location, since multi_index was omitted</span>
<span class="comments">;      p2=m.plot(/test,multi_index=2,symbol='circle') ;Third location, explicitly set with multi_index</span>
<span class="comments">;      </span>
<span class="comments">;    The result should look like</span>
<span class="comments">;    </span>
<span class="comments">;      .. image:: pp_multiplot_ex1.png</span>
<span class="comments">;    </span>
<span class="comments">;    Now, the x and y ranges on the second plot will be changed::</span>
<span class="comments">;    </span>
<span class="comments">;      p1.xrange=[50,100]</span>
<span class="comments">;      p1.yrange=[0,1]</span>
<span class="comments">;      m.sync_axes,1 ;Update the axes on the plot, taking the second one as reference.</span>
<span class="comments">;      </span>
<span class="comments">;    Now the plot will have a different x axis on the second column, and a different</span>
<span class="comments">;    y axis on the first line: .. image:: pp_multiplot_ex2.png</span>
<span class="comments">;    </span>
<span class="comments">;    These new ranges will automatically be used when a new plot is put on that</span>
<span class="comments">;    line/column::</span>
<span class="comments">;    </span>
<span class="comments">;      p3=m.plot(/test,multi_index=3) ;Fourth location, explicitly set with multi_index</span>
<span class="comments">;      </span>
<span class="comments">;    Now, save the output to a vector pdf, and close the window in the usual Graphics way::</span>
<span class="comments">;      </span>
<span class="comments">;      m.save,'pp_multiplot_ex3.pdf'</span>
<span class="comments">;      m.close</span>
<span class="comments">;      </span>
<span class="comments">;    The file would look like</span>
<span class="comments">;    </span>
<span class="comments">;      .. image:: pp_multiplot_ex3.png</span>
<span class="comments">;    </span>
<span class="comments">;    A more complicated example, with a 2x3 grid with variable widths and heights::</span>
<span class="comments">;    </span>
<span class="comments">;      m=pp_multiplot(multi_layout=[2,3],lineheights=[100,200,100],columnwidths=[100,200],/absolute_dims)</span>
<span class="comments">;      p0=m.plot(/test,color='red')</span>
<span class="comments">;      p1=m.plot(/test,color='blue',xrange=[50,100])</span>
<span class="comments">;      p2=m.plot(/test,color='green',ycolor='magenta',propagate=2) ;Make ycolor extend only to the second line</span>
<span class="comments">;      p3=m.plot(/test,linestyle='dotted')</span>
<span class="comments">;      p4=m.plot(/test,symbol='square')</span>
<span class="comments">;      p5=m.plot(/test,symbol='circle')</span>
<span class="comments">;      </span>
<span class="comments">;    Which would look like</span>
<span class="comments">;    </span>
<span class="comments">;     .. image:: pp_multiplot_ex4.png</span>
<span class="comments">;      </span>
<span class="comments">;    Now to retrieve some y properties of each line::</span>
<span class="comments">;    </span>
<span class="comments">;      print,m.yranges</span>
<span class="comments">;      ;     -0.82532734      0.93990618</span>
<span class="comments">;      ;     -0.82532734      0.93990618</span>
<span class="comments">;      ;     -0.82532734      0.93990618</span>
<span class="comments">;      print,m.ycolor</span>
<span class="comments">;      ;!NULL</span>
<span class="comments">;      ;magenta</span>
<span class="comments">;      ;!NULL</span>
<span class="comments">;      </span>
<span class="comments">;    Now to make the second column have red x axes::</span>
<span class="comments">;    </span>
<span class="comments">;      xcolor=m.xcolor</span>
<span class="comments">;      print,xcolor</span>
<span class="comments">;      ;!NULL</span>
<span class="comments">;      ;!NULL</span>
<span class="comments">;      xcolor[1]='red'</span>
<span class="comments">;      m.xcolor=xcolor</span>
<span class="comments">;      </span>
<span class="comments">;    Now to make all plots have larger y tick marks::</span>
<span class="comments">;    </span>
<span class="comments">;      m.yticklen=0.2</span>
<span class="comments">;      </span>
<span class="comments">;    The final result would be </span>
<span class="comments">;    </span>
<span class="comments">;     .. image:: pp_multiplot_ex5.png</span>
<span class="comments">;     </span>
<span class="comments">;    Save this window to a low resolution bitmap (same used in the documentation)</span>
<span class="comments">;    and close it::</span>
<span class="comments">;    </span>
<span class="comments">;      m.save,'pp_multiplot_ex5.png',resolution=100</span>
<span class="comments">;      m.close</span>
<span class="comments">;      </span>
<span class="comments">;    A simple example, with plots made with a set of default properties, so that</span>
<span class="comments">;    it is not necessary to repeat them for each plot::</span>
<span class="comments">;    </span>
<span class="comments">;      props={color:'red',symbol:'square',sym_filled:1}</span>
<span class="comments">;      m=pp_multiplot(multi_layout=[1,3],graphproperties=props)</span>
<span class="comments">;      p1=m.plot(/test)</span>
<span class="comments">;      p2=m.plot(/test)</span>
<span class="comments">;      p3=m.plot(/test,color='blue')</span>
<span class="comments">;      </span>
<span class="comments">;    The result would be</span>
<span class="comments">;</span>
<span class="comments">;     .. image:: pp_multiplot_ex6.png</span>
<span class="comments">;     </span>
<span class="comments">;    Now, we will change the yrange in one of the panels. This will cause the</span>
<span class="comments">;    axis tick labels to get recalculated, resulting in overlapping labels. This</span>
<span class="comments">;    would happen even if the new yrange was identical to the current range, beacuse</span>
<span class="comments">;    setting the range triggers a recalculation of the ticks::</span>
<span class="comments">;    </span>
<span class="comments">;       p2.yrange=[-1,2]</span>
<span class="comments">;       </span>
<span class="comments">;    Which looks like</span>
<span class="comments">;    </span>
<span class="comments">;    .. image:: pp_multiplot_ex7.png</span>
<span class="comments">;    </span>
<span class="comments">;    The fix to that is a call to the `updateranges` method::</span>
<span class="comments">;    </span>
<span class="comments">;      m.updateranges</span>
<span class="comments">;      </span>
<span class="comments">;    Which will make the plot look like</span>
<span class="comments">;    </span>
<span class="comments">;    .. image:: pp_multiplot_ex8.png</span>
<span class="comments">;       </span>
<span class="comments">;</span>
<span class="comments">; :Version: 20101027</span>
<span class="comments">; </span>
<span class="comments">; :Requires: IDL 8.0</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Sep/2010</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Creates an object to hold a grid of plots (from the plot function, of IDL</span>
<span class="comments">;    Graphics, not the plot procedure from direct graphics) with no empty space between lines</span>
<span class="comments">;    and columns, to use a single vertical/horizontal axis for each line/column</span>
<span class="comments">;    of plots. See the description of the class `pp_multiplot` for details</span>
<span class="comments">;    and examples.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">; </span>
<span class="comments">;    multi_layout: in, required</span>
<span class="comments">;      The layout of the grid to create, as a 2-element array [ncolumns, nlines],</span>
<span class="comments">;      with the number of columns and the number of lines for the grid.</span>
<span class="comments">;    title: in, optional</span>
<span class="comments">;      The title for the entire plot (passed on to the window object).</span>
<span class="comments">;    global_xtitle: in, optional</span>
<span class="comments">;      The common title for all the x axes, so that a same title does not have to</span>
<span class="comments">;      be shown repeatedly below every column.</span>
<span class="comments">;    global_ytitle: in, optional</span>
<span class="comments">;      The common title for all the y axes, so that a same title does not have to</span>
<span class="comments">;      be shown repeatedly on the left of every line.</span>
<span class="comments">;    global_margin: in, optional</span>
<span class="comments">;      The margins, in normalized units (range 0 to 1) to be given around the</span>
<span class="comments">;      grid. Provided as a 4-element array, for [left, bottom, right, top] margins.</span>
<span class="comments">;      Defaults to [0.125d0,0.15d0,0.005d0,0.1d0].</span>
<span class="comments">;    columnwidths: in, optional</span>
<span class="comments">;      If set to an array with the same number of elements as the number of grid</span>
<span class="comments">;      columns, specifies the width to use for each plot column. If not provided,</span>
<span class="comments">;      equal widths are used. The units are arbitrary, as only their relative values</span>
<span class="comments">;      is used, unless `absolute_dims` is set, in which case the units are the same</span>
<span class="comments">;      as window()'s dimensions. </span>
<span class="comments">;    lineheights: in, optional</span>
<span class="comments">;      If set to an array with the same number of elements as the number of grid</span>
<span class="comments">;      lines, specifies the height to use for each plot column. If not provided,</span>
<span class="comments">;      equal heights are used. The units are arbitrary, as only their relative values</span>
<span class="comments">;      is used, unless `absolute_dims` is set, in which case the units are the same</span>
<span class="comments">;      as window()'s dimensions.</span>
<span class="comments">;    absolute_dims: in, optional, default=0</span>
<span class="comments">;      If set, causes `columnwidths` and `lineheights` to be interpreted as absolute,</span>
<span class="comments">;      rather than relative values. In that case, their units are the same as those</span>
<span class="comments">;      used by window()'s dimensions. </span>
<span class="comments">;    _REF_EXTRA: in, out, optional</span>
<span class="comments">;      Any extra properties are just passed to window() (the init method of the</span>
<span class="comments">;      window class). The most common to be used is probably going to be dimensions.</span>
<span class="comments">;      See the help on window() for more information.</span>
<span class="comments">;    graphproperties: in, optional</span>
<span class="comments">;      Use this keyword to provide a set of graphic keywords to be passed to all</span>
<span class="comments">;      individual graphs by default. It should be in the form of a structure, with</span>
<span class="comments">;      each field containing the value for the keyword of corresponding name.</span>
<span class="comments">;      If an individual graph's creation specifies a value for a keyword given in</span>
<span class="comments">;      graphproperties, it will take precendece over the graphproperties value.</span>
<span class="comments">;      See examples above. </span>
<span class="comments">;      </span>
<span class="comments">;-</span>
<a id="pp_multiplot::init:source"></a>function pp_multiplot::init,_REF_EXTRA=ex,$
 multi_layout=mlayout,title=gtitle,global_xtitle=gxtitle,global_ytitle=gytitle,$
 global_margin=gmargin,columnwidths=cwidths,lineheights=lheights,absolute_dims=absolute,$
 xgap=xgap,ygap=ygap,xsupressdivision=xsupressdivision,ysupressdivision=ysupressdivision,$
 graphproperties=graphproperties,xtickratio=xtickratio,ytickratio=ytickratio
compile_opt idl2, logical_predicate

if (n_elements(mlayout) ne 2) then begin
  print,'multi_layout must be a 2-element integer array'
  return,0
endif

<span class="comments">;Defaults</span>
<span class="comments">;Are the widths and heigths provided to be interpreted as absolute or relative dimensions? </span>
absolute=(n_elements(absolute) eq 1) ? absolute : 0

<span class="comments">;Grid shape</span>
self.mlayout=round(mlayout)
ncolumns=self.mlayout[0]
nlines=self.mlayout[1]
self.ncolumns=ncolumns
self.nlines=nlines

<span class="comments">;Initialize lists</span>
self.oplots=list(length=self.mlayout[0]*self.mlayout[1])
<span class="comments">;Set equal widths and heights by default</span>
if (n_elements(cwidths) eq ncolumns) then self.cwidths=list(cwidths/total(cwidths),/extract) $
 else self.cwidths=list(replicate(1d0/ncolumns,ncolumns),/extract)
if (n_elements(lheights) eq nlines) then self.lheights=list(lheights/total(lheights),/extract) $
 else self.lheights=list(replicate(1d0/nlines,nlines),/extract)
self.xranges=list(length=ncolumns)
self.yranges=list(length=nlines)
keynames=['COLOR','GRIDSTYLE','LOG','MAJOR','MINOR','SUBTICKLEN','TEXT_COLOR',$
 'TEXT_POS','THICK','TICKDIR','TICKFONT_NAME','TICKFONT_SIZE','TICKFONT_STYLE',$
 'TICKFORMAT','TICKINTERVAL','TICKLAYOUT','TICKLEN','TICKNAME','TICKUNITS','TICKVALUES',$
 'TITLE','TRANSPARENCY']
self.xproperties=list()
for i=0,ncolumns-1 do self.xproperties.add,hash('X'+keynames)
self.yproperties=list()
for i=0,nlines-1 do self.yproperties.add,hash('Y'+keynames)
self.xendticks=list(length=nlines*ncolumns)
self.yendticks=list(length=nlines*ncolumns)

<span class="comments">;Process optional parameters</span>
<span class="comments">;Default margins</span>
self.global_margin=[0.125d0,0.15d0,0.005d0,0.1d0]
if (n_elements(gmargin) eq 4) then self.global_margin=gmargin
if (n_elements(xranges) ne 0) then self.setproperty,xranges=xranges
if (n_elements(yranges) ne 0) then self.setproperty,yranges=yranges
if (n_elements(ygap) ne 0) then self.ygap=ygap
if (n_elements(xgap) ne 0) then self.xgap=xgap

<span class="comments">;Create the window to contain the graphics</span>
if absolute then begin
  if (n_elements(dimensions) ne 2) then begin
    <span class="comments">;Compute window dimensions to give the proper margins in addition to the line/column dimensions </span>
    totalw=total(cwidths)/(1d0-total((self.global_margin)[[0,2]]))
    totalh=total(lheights)/(1d0-total((self.global_margin)[[1,3]]))
    dimensions=[totalw,totalh]
  <span class="comments">;Or take the absolute dimensions given for the window and ignore relative margins</span>
  endif else self.global_margin=[0d0,0d0,0d0,0d0]
  self.owindow=window(_extra=ex,title=gtitle,dimensions=dimensions)
endif else self.owindow=window(_extra=ex,title=gtitle)

<span class="comments">;Parameters that depend on the window's existence</span>
if (n_elements(gxtitle) eq 1) then self.setproperty,global_xtitle=gxtitle
if (n_elements(gytitle) eq 1) then self.setproperty,global_ytitle=gytitle
if (n_elements(gtitle) ne 0) then self.setproperty,title=gtitle
if (n_elements(xsupressdivision) ne 0) then self.xsupressdivision=xsupressdivision
if (n_elements(ysupressdivision) ne 0) then self.ysupressdivision=ysupressdivision
self.xtickratio=n_elements(xtickratio) ? xtickratio : 0.2d0
self.ytickratio=n_elements(ytickratio) ? ytickratio : 0.2d0

self.graphproperties=n_elements(graphproperties) ? hash(graphproperties) : hash()

return,isa(self.owindow,'graphicswin') || isa(self.owindow,'graphicsbuffer')
end


<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    A wrapper for plot(), which creates the plot in the proper place and with</span>
<span class="comments">;    the right properties (particularly x/y ranges) in the multiplot grid, adding</span>
<span class="comments">;    the object to the list of plots contained by the pp_multiplot object.</span>
<span class="comments">;    </span>
<span class="comments">; :Returns:</span>
<span class="comments">;    The plot object created in the multiplot grid. This is a regular object of</span>
<span class="comments">;    IDL's plot class, and can be manipulated in the usual way. The method</span>
<span class="comments">;    `pp_multiplot::sync_axes` can be used to synchronize axes properties across</span>
<span class="comments">;    a line/column or all plots, after one plot has been changed (programmatically</span>
<span class="comments">;    or interactively). </span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    arg1: in, optional</span>
<span class="comments">;      The first argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;    arg2: in, optional</span>
<span class="comments">;      The second argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;    arg3: in, optional</span>
<span class="comments">;      The third argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    TEST: in, optional, default=0</span>
<span class="comments">;      Passed on to plot(), to make plot() used the test data instead.</span>
<span class="comments">;    multi_index: in, optional</span>
<span class="comments">;      The index of the position to place the plot in the grid. Count starts at</span>
<span class="comments">;      0, on the top left, proceeding left-to-right, then top-to-bottom, up to</span>
<span class="comments">;      nlines*ncolumns-1.</span>
<span class="comments">;    xrange: in, optional</span>
<span class="comments">;      A 2-element array with the minimum and maximum to use for the x axis. If</span>
<span class="comments">;      not provided, the xrange set for the current column is used, or, if no range</span>
<span class="comments">;      was set for the column, the plot is created with the default range</span>
<span class="comments">;      (determined by plot()), and that range is subsequently set for the column</span>
<span class="comments">;      The other plots in the column have their ranges updated, if necessary. </span>
<span class="comments">;    yrange: in, optional</span>
<span class="comments">;      A 2-element array with the minimum and maximum to use for the y axis. If</span>
<span class="comments">;      not provided, the xrange set for the current line is used, or, if no range</span>
<span class="comments">;      was set for the line, the plot is created with the default range</span>
<span class="comments">;      (determined by plot()), and that range is subsequently set for the line</span>
<span class="comments">;      The other plots in the line have their ranges updated, if necessary.</span>
<span class="comments">;    propagate: in, optional, default=1</span>
<span class="comments">;      Determines the mode of propagating the axes properties (range and endticks</span>
<span class="comments">;      not included) of this plot. If 0, no propagation of properties is done.</span>
<span class="comments">;      If 1, properties are propagated to all plots in the grid.</span>
<span class="comments">;      If 2, properties are propagated to all plots in the same line/column.</span>
<span class="comments">;    xendticks: in, optional</span>
<span class="comments">;      The mode set for suppressing the first/last x tick labels of the plot: 0</span>
<span class="comments">;      means that both the first and last labels are suppressed, 1 means that only</span>
<span class="comments">;      the last label is suppressed, 2 means that only the first label is suppressed,</span>
<span class="comments">;      and 3 means that neither is suppressed. The default for each plot depends</span>
<span class="comments">;      on its location on the multiplot grid (its mindex): Plots have their last</span>
<span class="comments">;      label suppressed (xendticks=1), except for those that fall on the rightmost</span>
<span class="comments">;      column (xendticks=3).</span>
<span class="comments">;    yendticks: in, optional</span>
<span class="comments">;      The mode set for suppressing the first/last y tick labels of the plot: 0</span>
<span class="comments">;      means that both the first and last labels are suppressed, 1 means that only</span>
<span class="comments">;      the last label is suppressed, 2 means that only the first label is suppressed,</span>
<span class="comments">;      and 3 means that neither is suppressed. The default for each plot depends</span>
<span class="comments">;      on its location on the multiplot grid (its mindex): Plots have their last</span>
<span class="comments">;      label suppressed (yendticks=1), except for those that fall on the top</span>
<span class="comments">;      line (yendticks=3).</span>
<span class="comments">;    _EXTRA: in, optional</span>
<span class="comments">;      Any keywords not handled by this method are passed on to plot(). See the</span>
<span class="comments">;      help on plot() for details.</span>
<span class="comments">;      </span>
<span class="comments">;      The following properties are axes properties, that can be made common across</span>
<span class="comments">;      columns (x) or lines (y) with the keyword `propagate`. See the help on plot</span>
<span class="comments">;      objects for details:</span>
<span class="comments">;      </span>
<span class="comments">;      [XY]COLOR, [XY]GRIDSTYLE, [XY]LOG, [XY]MAJOR, [XY]MINOR, [XY]SUBTICKLEN, [XY]TEXT_COLOR, </span>
<span class="comments">;      [XY]TEXT_POS, [XY]THICK, [XY]TICKDIR, [XY]TICKFONT_NAME, [XY]TICKFONT_SIZE, [XY]TICKFONT_STYLE, </span>
<span class="comments">;      [XY]TICKFORMAT, [XY]TICKINTERVAL, [XY]TICKLAYOUT, [XY]TICKLEN, [XY]TICKNAME, [XY]TICKUNITS, </span>
<span class="comments">;      [XY]TICKVALUES, [XY]TITLE, [XY]TRANSPARENCY</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="pp_multiplot::plot:source"></a>function pp_multiplot::plot,arg1, arg2, arg3, TEST=test, _EXTRA=ex,$
 multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
 xendticks=xendticks,yendticks=yendticks
compile_opt idl2, logical_predicate
graphic_to_do='plot'
case n_params() of
  0: ret=self.do_graphic(graphic_to_do=graphic_to_do, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks)
  1: ret=self.do_graphic(graphic_to_do=graphic_to_do,arg1, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks)
  2: ret=self.do_graphic(graphic_to_do=graphic_to_do,arg1, arg2, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks)
  3: ret=self.do_graphic(graphic_to_do=graphic_to_do,arg1, arg2, arg3, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks)
endcase
return,ret
end


<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    A wrapper for contour(), which creates the image in the proper place and with</span>
<span class="comments">;    the right properties (particularly x/y ranges) in the multiplot grid, adding</span>
<span class="comments">;    the object to the list of plots contained by the pp_multiplot object.</span>
<span class="comments">;    </span>
<span class="comments">; :Returns:</span>
<span class="comments">;    The contour object created in the multiplot grid. This is a regular object of</span>
<span class="comments">;    IDL's image class, and can be manipulated in the usual way. The method</span>
<span class="comments">;    `pp_multiplot::sync_axes` can be used to synchronize axes properties across</span>
<span class="comments">;    a line/column or all plots, after one plot has been changed (programmatically</span>
<span class="comments">;    or interactively). </span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    arg1: in, optional</span>
<span class="comments">;      The first argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;    arg2: in, optional</span>
<span class="comments">;      The second argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;    arg3: in, optional</span>
<span class="comments">;      The third argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    TEST: in, optional, default=0</span>
<span class="comments">;      Passed on to plot(), to make plot() used the test data instead.</span>
<span class="comments">;    multi_index: in, optional</span>
<span class="comments">;      The index of the position to place the plot in the grid. Count starts at</span>
<span class="comments">;      0, on the top left, proceeding left-to-right, then top-to-bottom, up to</span>
<span class="comments">;      nlines*ncolumns-1.</span>
<span class="comments">;    xrange: in, optional</span>
<span class="comments">;      A 2-element array with the minimum and maximum to use for the x axis. If</span>
<span class="comments">;      not provided, the xrange set for the current column is used, or, if no range</span>
<span class="comments">;      was set for the column, the plot is created with the default range</span>
<span class="comments">;      (determined by plot()), and that range is subsequently set for the column</span>
<span class="comments">;      The other plots in the column have their ranges updated, if necessary. </span>
<span class="comments">;    yrange: in, optional</span>
<span class="comments">;      A 2-element array with the minimum and maximum to use for the y axis. If</span>
<span class="comments">;      not provided, the xrange set for the current line is used, or, if no range</span>
<span class="comments">;      was set for the line, the plot is created with the default range</span>
<span class="comments">;      (determined by plot()), and that range is subsequently set for the line</span>
<span class="comments">;      The other plots in the line have their ranges updated, if necessary.</span>
<span class="comments">;    propagate: in, optional, default=1</span>
<span class="comments">;      Determines the mode of propagating the axes properties (range and endticks</span>
<span class="comments">;      not included) of this plot. If 0, no propagation of properties is done.</span>
<span class="comments">;      If 1, properties are propagated to all plots in the grid.</span>
<span class="comments">;      If 2, properties are propagated to all plots in the same line/column.</span>
<span class="comments">;    xendticks: in, optional</span>
<span class="comments">;      The mode set for suppressing the first/last x tick labels of the plot: 0</span>
<span class="comments">;      means that both the first and last labels are suppressed, 1 means that only</span>
<span class="comments">;      the last label is suppressed, 2 means that only the first label is suppressed,</span>
<span class="comments">;      and 3 means that neither is suppressed. The default for each plot depends</span>
<span class="comments">;      on its location on the multiplot grid (its mindex): Plots have their last</span>
<span class="comments">;      label suppressed (xendticks=1), except for those that fall on the rightmost</span>
<span class="comments">;      column (xendticks=3).</span>
<span class="comments">;    yendticks: in, optional</span>
<span class="comments">;      The mode set for suppressing the first/last y tick labels of the plot: 0</span>
<span class="comments">;      means that both the first and last labels are suppressed, 1 means that only</span>
<span class="comments">;      the last label is suppressed, 2 means that only the first label is suppressed,</span>
<span class="comments">;      and 3 means that neither is suppressed. The default for each plot depends</span>
<span class="comments">;      on its location on the multiplot grid (its mindex): Plots have their last</span>
<span class="comments">;      label suppressed (yendticks=1), except for those that fall on the top</span>
<span class="comments">;      line (yendticks=3).</span>
<span class="comments">;    _EXTRA: in, optional</span>
<span class="comments">;      Any keywords not handled by this method are passed on to plot(). See the</span>
<span class="comments">;      help on plot() for details.</span>
<span class="comments">;      </span>
<span class="comments">;      The following properties are axes properties, that can be made common across</span>
<span class="comments">;      columns (x) or lines (y) with the keyword `propagate`. See the help on plot</span>
<span class="comments">;      objects for details:</span>
<span class="comments">;      </span>
<span class="comments">;      [XY]COLOR, [XY]GRIDSTYLE, [XY]LOG, [XY]MAJOR, [XY]MINOR, [XY]SUBTICKLEN, [XY]TEXT_COLOR, </span>
<span class="comments">;      [XY]TEXT_POS, [XY]THICK, [XY]TICKDIR, [XY]TICKFONT_NAME, [XY]TICKFONT_SIZE, [XY]TICKFONT_STYLE, </span>
<span class="comments">;      [XY]TICKFORMAT, [XY]TICKINTERVAL, [XY]TICKLAYOUT, [XY]TICKLEN, [XY]TICKNAME, [XY]TICKUNITS, </span>
<span class="comments">;      [XY]TICKVALUES, [XY]TITLE, [XY]TRANSPARENCY</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="pp_multiplot::contour:source"></a>function pp_multiplot::contour,arg1, arg2, arg3, TEST=test, _EXTRA=ex,$
 multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
 xendticks=xendticks,yendticks=yendticks
compile_opt idl2, logical_predicate
graphic_to_do='contour'
case n_params() of
  0: ret=self.do_graphic(graphic_to_do=graphic_to_do, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks)
  1: ret=self.do_graphic(graphic_to_do=graphic_to_do,arg1, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks)
  2: ret=self.do_graphic(graphic_to_do=graphic_to_do,arg1, arg2, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks)
  3: ret=self.do_graphic(graphic_to_do=graphic_to_do,arg1, arg2, arg3, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks)
endcase
return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    A wrapper for image(), which creates the image in the proper place and with</span>
<span class="comments">;    the right properties (particularly x/y ranges) in the multiplot grid, adding</span>
<span class="comments">;    the object to the list of plots contained by the pp_multiplot object.</span>
<span class="comments">;    </span>
<span class="comments">; :Returns:</span>
<span class="comments">;    The image object created in the multiplot grid. This is a regular object of</span>
<span class="comments">;    IDL's image class, and can be manipulated in the usual way. The method</span>
<span class="comments">;    `pp_multiplot::sync_axes` can be used to synchronize axes properties across</span>
<span class="comments">;    a line/column or all plots, after one plot has been changed (programmatically</span>
<span class="comments">;    or interactively). </span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    arg1: in, optional</span>
<span class="comments">;      The first argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;    arg2: in, optional</span>
<span class="comments">;      The second argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;    arg3: in, optional</span>
<span class="comments">;      The third argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    TEST: in, optional, default=0</span>
<span class="comments">;      Passed on to plot(), to make plot() used the test data instead.</span>
<span class="comments">;    multi_index: in, optional</span>
<span class="comments">;      The index of the position to place the plot in the grid. Count starts at</span>
<span class="comments">;      0, on the top left, proceeding left-to-right, then top-to-bottom, up to</span>
<span class="comments">;      nlines*ncolumns-1.</span>
<span class="comments">;    xrange: in, optional</span>
<span class="comments">;      A 2-element array with the minimum and maximum to use for the x axis. If</span>
<span class="comments">;      not provided, the xrange set for the current column is used, or, if no range</span>
<span class="comments">;      was set for the column, the plot is created with the default range</span>
<span class="comments">;      (determined by plot()), and that range is subsequently set for the column</span>
<span class="comments">;      The other plots in the column have their ranges updated, if necessary. </span>
<span class="comments">;    yrange: in, optional</span>
<span class="comments">;      A 2-element array with the minimum and maximum to use for the y axis. If</span>
<span class="comments">;      not provided, the xrange set for the current line is used, or, if no range</span>
<span class="comments">;      was set for the line, the plot is created with the default range</span>
<span class="comments">;      (determined by plot()), and that range is subsequently set for the line</span>
<span class="comments">;      The other plots in the line have their ranges updated, if necessary.</span>
<span class="comments">;    propagate: in, optional, default=1</span>
<span class="comments">;      Determines the mode of propagating the axes properties (range and endticks</span>
<span class="comments">;      not included) of this plot. If 0, no propagation of properties is done.</span>
<span class="comments">;      If 1, properties are propagated to all plots in the grid.</span>
<span class="comments">;      If 2, properties are propagated to all plots in the same line/column.</span>
<span class="comments">;    xendticks: in, optional</span>
<span class="comments">;      The mode set for suppressing the first/last x tick labels of the plot: 0</span>
<span class="comments">;      means that both the first and last labels are suppressed, 1 means that only</span>
<span class="comments">;      the last label is suppressed, 2 means that only the first label is suppressed,</span>
<span class="comments">;      and 3 means that neither is suppressed. The default for each plot depends</span>
<span class="comments">;      on its location on the multiplot grid (its mindex): Plots have their last</span>
<span class="comments">;      label suppressed (xendticks=1), except for those that fall on the rightmost</span>
<span class="comments">;      column (xendticks=3).</span>
<span class="comments">;    yendticks: in, optional</span>
<span class="comments">;      The mode set for suppressing the first/last y tick labels of the plot: 0</span>
<span class="comments">;      means that both the first and last labels are suppressed, 1 means that only</span>
<span class="comments">;      the last label is suppressed, 2 means that only the first label is suppressed,</span>
<span class="comments">;      and 3 means that neither is suppressed. The default for each plot depends</span>
<span class="comments">;      on its location on the multiplot grid (its mindex): Plots have their last</span>
<span class="comments">;      label suppressed (yendticks=1), except for those that fall on the top</span>
<span class="comments">;      line (yendticks=3).</span>
<span class="comments">;    _EXTRA: in, optional</span>
<span class="comments">;      Any keywords not handled by this method are passed on to plot(). See the</span>
<span class="comments">;      help on plot() for details.</span>
<span class="comments">;      </span>
<span class="comments">;      The following properties are axes properties, that can be made common across</span>
<span class="comments">;      columns (x) or lines (y) with the keyword `propagate`. See the help on plot</span>
<span class="comments">;      objects for details:</span>
<span class="comments">;      </span>
<span class="comments">;      [XY]COLOR, [XY]GRIDSTYLE, [XY]LOG, [XY]MAJOR, [XY]MINOR, [XY]SUBTICKLEN, [XY]TEXT_COLOR, </span>
<span class="comments">;      [XY]TEXT_POS, [XY]THICK, [XY]TICKDIR, [XY]TICKFONT_NAME, [XY]TICKFONT_SIZE, [XY]TICKFONT_STYLE, </span>
<span class="comments">;      [XY]TICKFORMAT, [XY]TICKINTERVAL, [XY]TICKLAYOUT, [XY]TICKLEN, [XY]TICKNAME, [XY]TICKUNITS, </span>
<span class="comments">;      [XY]TICKVALUES, [XY]TITLE, [XY]TRANSPARENCY</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="pp_multiplot::image:source"></a>function pp_multiplot::image,arg1, arg2, arg3, TEST=test, _EXTRA=ex,$
 multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
 xendticks=xendticks,yendticks=yendticks,axis_style=axs,aspect_ratio=ar
compile_opt idl2, logical_predicate
graphic_to_do='image'
axs=n_elements(axs) ? axs : 2
ar=n_elements(ar) ? ar : 0
case n_params() of
  0: ret=self.do_graphic(graphic_to_do=graphic_to_do, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks,axis_style=axs,aspect_ratio=ar)
  1: ret=self.do_graphic(graphic_to_do=graphic_to_do,arg1, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks,axis_style=axs,aspect_ratio=ar)
  2: ret=self.do_graphic(graphic_to_do=graphic_to_do,arg1, arg2, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks,axis_style=axs,aspect_ratio=ar)
  3: ret=self.do_graphic(graphic_to_do=graphic_to_do,arg1, arg2, arg3, TEST=test, _EXTRA=ex,$
   multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
   xendticks=xendticks,yendticks=yendticks,axis_style=axs,aspect_ratio=ar)
endcase
return,ret
end


<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    A wrapper for plot(), image() and contour(), which creates the plot in the</span>
<span class="comments">;    proper place and with the right properties (particularly x/y ranges) in the</span>
<span class="comments">;    multiplot grid, adding the object to the list of plots contained by the</span>
<span class="comments">;    pp_multiplot object.</span>
<span class="comments">;    </span>
<span class="comments">; :Returns:</span>
<span class="comments">;    The plot object created in the multiplot grid. This is a regular object of</span>
<span class="comments">;    IDL's plot class, and can be manipulated in the usual way. The method</span>
<span class="comments">;    `pp_multiplot::sync_axes` can be used to synchronize axes properties across</span>
<span class="comments">;    a line/column or all plots, after one plot has been changed (programmatically</span>
<span class="comments">;    or interactively). </span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    arg1: in, optional</span>
<span class="comments">;      The first argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;    arg2: in, optional</span>
<span class="comments">;      The second argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;    arg3: in, optional</span>
<span class="comments">;      The third argument to be passed on to plot(). See the help on plot()</span>
<span class="comments">;      for details.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    TEST: in, optional, default=0</span>
<span class="comments">;      Passed on to plot(), to make plot() used the test data instead.</span>
<span class="comments">;    multi_index: in, optional</span>
<span class="comments">;      The index of the position to place the plot in the grid. Count starts at</span>
<span class="comments">;      0, on the top left, proceeding left-to-right, then top-to-bottom, up to</span>
<span class="comments">;      nlines*ncolumns-1.</span>
<span class="comments">;    xrange: in, optional</span>
<span class="comments">;      A 2-element array with the minimum and maximum to use for the x axis. If</span>
<span class="comments">;      not provided, the xrange set for the current column is used, or, if no range</span>
<span class="comments">;      was set for the column, the plot is created with the default range</span>
<span class="comments">;      (determined by plot()), and that range is subsequently set for the column</span>
<span class="comments">;      The other plots in the column have their ranges updated, if necessary. </span>
<span class="comments">;    yrange: in, optional</span>
<span class="comments">;      A 2-element array with the minimum and maximum to use for the y axis. If</span>
<span class="comments">;      not provided, the xrange set for the current line is used, or, if no range</span>
<span class="comments">;      was set for the line, the plot is created with the default range</span>
<span class="comments">;      (determined by plot()), and that range is subsequently set for the line</span>
<span class="comments">;      The other plots in the line have their ranges updated, if necessary.</span>
<span class="comments">;    propagate: in, optional, default=1</span>
<span class="comments">;      Determines the mode of propagating the axes properties (range and endticks</span>
<span class="comments">;      not included) of this plot. If 0, no propagation of properties is done.</span>
<span class="comments">;      If 1, properties are propagated to all plots in the grid.</span>
<span class="comments">;      If 2, properties are propagated to all plots in the same line/column.</span>
<span class="comments">;    xendticks: in, optional</span>
<span class="comments">;      The mode set for suppressing the first/last x tick labels of the plot: 0</span>
<span class="comments">;      means that both the first and last labels are suppressed, 1 means that only</span>
<span class="comments">;      the last label is suppressed, 2 means that only the first label is suppressed,</span>
<span class="comments">;      and 3 means that neither is suppressed. The default for each plot depends</span>
<span class="comments">;      on its location on the multiplot grid (its mindex): Plots have their last</span>
<span class="comments">;      label suppressed (xendticks=1), except for those that fall on the rightmost</span>
<span class="comments">;      column (xendticks=3).</span>
<span class="comments">;    yendticks: in, optional</span>
<span class="comments">;      The mode set for suppressing the first/last y tick labels of the plot: 0</span>
<span class="comments">;      means that both the first and last labels are suppressed, 1 means that only</span>
<span class="comments">;      the last label is suppressed, 2 means that only the first label is suppressed,</span>
<span class="comments">;      and 3 means that neither is suppressed. The default for each plot depends</span>
<span class="comments">;      on its location on the multiplot grid (its mindex): Plots have their last</span>
<span class="comments">;      label suppressed (yendticks=1), except for those that fall on the top</span>
<span class="comments">;      line (yendticks=3).</span>
<span class="comments">;    _EXTRA: in, optional</span>
<span class="comments">;      Any keywords not handled by this method are passed on to plot(). See the</span>
<span class="comments">;      help on plot() for details.</span>
<span class="comments">;      </span>
<span class="comments">;      The following properties are axes properties, that can be made common across</span>
<span class="comments">;      columns (x) or lines (y) with the keyword `propagate`. See the help on plot</span>
<span class="comments">;      objects for details:</span>
<span class="comments">;      </span>
<span class="comments">;      [XY]COLOR, [XY]GRIDSTYLE, [XY]LOG, [XY]MAJOR, [XY]MINOR, [XY]SUBTICKLEN, [XY]TEXT_COLOR, </span>
<span class="comments">;      [XY]TEXT_POS, [XY]THICK, [XY]TICKDIR, [XY]TICKFONT_NAME, [XY]TICKFONT_SIZE, [XY]TICKFONT_STYLE, </span>
<span class="comments">;      [XY]TICKFORMAT, [XY]TICKINTERVAL, [XY]TICKLAYOUT, [XY]TICKLEN, [XY]TICKNAME, [XY]TICKUNITS, </span>
<span class="comments">;      [XY]TICKVALUES, [XY]TITLE, [XY]TRANSPARENCY</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="pp_multiplot::do_graphic:source"></a>function pp_multiplot::do_graphic,graphic_to_do=graphic_to_do,$
 arg1, arg2, arg3, TEST=test, _EXTRA=ex,$
 multi_index=mindex,xrange=xrange,yrange=yrange,propagate=propagate,$
 xendticks=xendticks,yendticks=yendticks
compile_opt idl2, logical_predicate

<span class="comments">;Defaults</span>
mindex=n_elements(mindex) eq 1 ? 0>mindex&lt;(self.mlayout[0]*self.mlayout[1]-1) : self.mindex
self.mindex=mindex <span class="comments">;The index of the current location in the multiplot matrix</span>
<span class="comments">;Propagate [xy]properties over nothing (0), all (1), line/column (2)</span>
propagate=(n_elements(propagate) eq 1) ? propagate : 1

<span class="comments">;Determine the location for the plot</span>
position=self.getposition(mindex,bottom=bottom,left=left,top=top,right=right,column=column,line=line)

<span class="comments">;By default, supress end x/y ticks in plots that are in the middle of the columns/lines</span>
if n_elements(xendticks) ne 1 then begin
  xendticks=right ? 3 : 1
  fixxticks=right ? 0 : 1
endif else fixxticks=0
if n_elements(yendticks) ne 1 then begin
  yendticks=top ? 3 : 1
  fixyticks=top ? 0 : 1
endif else fixyticks=0
<span class="comments">;xendticks=n_elements(xendticks) eq 1 ? xendticks : right ? 3 : 1</span>
<span class="comments">;yendticks=n_elements(yendticks) eq 1 ? yendticks : top ? 3 : 1   </span>

<span class="comments">;Update the [xy]range, if provided</span>
if (n_elements(xrange) eq 2) then begin
  newxranges=(self.xranges)[*]
  newxranges[column]=xrange
  self.setproperty,xranges=newxranges
endif
if (n_elements(yrange) eq 2) then begin
  newyranges=(self.yranges)[*]
  newyranges[line]=yrange
  self.setproperty,yranges=newyranges
endif

<span class="comments">;Process the axes properties in the extra parameters</span>
ex=(self.process_extras_plot(hash(ex),mindex,propagate)).tostruct()
<span class="comments">;Combine extras with default properties</span>
if self.graphproperties then begin
  exh=hash(ex)
  exh=self.graphproperties+exh
  ex=exh.tostruct()
endif

<span class="comments">;Create the plot object</span>
self.owindow.select,/clear <span class="comments">;Just to make this window the current one</span>
if !version.release ge '8.2' then begin
  case n_params() of
    0:ret=call_function(graphic_to_do,TEST=test, _EXTRA=ex,position=position,/current,$
     xshowtext=bottom*1,yshowtext=left*1,xrange=(self.xranges)[column],yrange=(self.yranges)[line])
    1:ret=call_function(graphic_to_do,arg1,TEST=test, _EXTRA=ex,position=position,/current,$
     xshowtext=bottom*1,yshowtext=left*1,xrange=(self.xranges)[column],yrange=(self.yranges)[line])
    2:ret=call_function(graphic_to_do,arg1,arg2,TEST=test, _EXTRA=ex,position=position,/current,$
     xshowtext=bottom*1,yshowtext=left*1,xrange=(self.xranges)[column],yrange=(self.yranges)[line])
    3:ret=call_function(graphic_to_do,arg1,arg2,arg3,TEST=test, _EXTRA=ex,position=position,/current,$
     xshowtext=bottom*1,yshowtext=left*1,xrange=(self.xranges)[column],yrange=(self.yranges)[line])
  endcase
  axes=ret.axes
  axes[2].showtext=0
  axes[3].showtext=0
endif else begin
  case n_params() of
    0:ret=call_function(graphic_to_do,TEST=test, _EXTRA=ex,position=position,/current,$
      xtickfont_size=bottom*12,ytickfont_size=left*12,xrange=(self.xranges)[column],yrange=(self.yranges)[line])
    1:ret=call_function(graphic_to_do,arg1,TEST=test, _EXTRA=ex,position=position,/current,$
      xtickfont_size=bottom*12,ytickfont_size=left*12,xrange=(self.xranges)[column],yrange=(self.yranges)[line])
    2:ret=call_function(graphic_to_do,arg1,arg2,TEST=test, _EXTRA=ex,position=position,/current,$
      xtickfont_size=bottom*12,ytickfont_size=left*12,xrange=(self.xranges)[column],yrange=(self.yranges)[line])
    3:ret=call_function(graphic_to_do,arg1,arg2,arg3,TEST=test, _EXTRA=ex,position=position,/current,$
      xtickfont_size=bottom*12,ytickfont_size=left*12,xrange=(self.xranges)[column],yrange=(self.yranges)[line])
  endcase  
endelse

<span class="comments">;Set the [xy]range, if necessary</span>
if (~isa((self.xranges)[column])) then (self.xranges)[column]=ret.xrange
if (~isa((self.yranges)[line])) then (self.yranges)[line]=ret.yrange
if ~array_equal((self.xranges)[column],ret.xrange) then (self.xranges)[column]=ret.xrange
if ~array_equal((self.yranges)[line],ret.yrange) then (self.yranges)[line]=ret.yrange




<span class="comments">;Remove the first/last labels, if necessary</span>
self.setendticks,xendticks,ret,'x'
self.setendticks,yendticks,ret,'y'

(self.oplots)[mindex]=ret
(self.xendticks)[mindex]=xendticks
(self.yendticks)[mindex]=yendticks
<span class="comments">;Change the default grid index to the next one </span>
if mindex lt (self.mlayout[0]*self.mlayout[1]-1) then self.mindex++

if self.xsupressdivision then begin
  if ~left then ret['axis1'].hide=1
  if ~right then ret['axis3'].hide=1
endif

if self.ysupressdivision then begin
  if ~bottom then ret['axis0'].hide=1
  if ~top then ret['axis2'].hide=1
endif

return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Processes the extra parameters passed to `pp_multiplot::plot`, to pick those</span>
<span class="comments">;    that specify axes properties. Axes properties are given a special treatment,</span>
<span class="comments">;    as they might be kept synchronized across lines/column/all plots. </span>
<span class="comments">;    </span>
<span class="comments">;  :Hidden: This routine is to be used only by `pp_multiplot::plot`.</span>
<span class="comments">;  </span>
<span class="comments">;  :Private: This routine is to be used only by `pp_multiplot::plot`.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    extras: in, required</span>
<span class="comments">;      Extra parameters passed to `pp_multiplot::plot`, converted to a hash, to be processed here.</span>
<span class="comments">;    mindex: in, required</span>
<span class="comments">;      The index of the plot being processed in the multiplot grid (0 to nlines*ncolumns-1).</span>
<span class="comments">;    propagate: in, required</span>
<span class="comments">;      If 0, no propagation of properties is done. If 1, properties are propagated</span>
<span class="comments">;      to all plots. If 2, properties are propagated to all</span>
<span class="comments">;      plots in the same line/column.</span>
<span class="comments">;      </span>
<span class="comments">;  :Returns:</span>
<span class="comments">;    A hash with the extra parameters that should be passed to plot(), which</span>
<span class="comments">;    includes those that were not altered here, and those that were processed</span>
<span class="comments">;    based on the x/y properties for that position in the grid.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="pp_multiplot::process_extras_plot:source"></a>function pp_multiplot::process_extras_plot,extras,mindex,propagate
compile_opt idl2, logical_predicate,hidden

if (n_elements(extras) eq 0) then return,extras <span class="comments">;Get out now if nothing has to be done</span>

column=mindex mod self.ncolumns
line=mindex/self.ncolumns

<span class="comments">;Get the hashes of the currently set properties</span>
currentx=((self.xproperties)[column])[*]
currenty=((self.yproperties)[line])[*]
to_update=hash() <span class="comments">;Indices of the plots that will have to be updated</span>
foreach el,extras,i do begin <span class="comments">;Parse each extra argument, if it is an x/y property</span>
  if currentx.haskey(i) then begin <span class="comments">;If it is one of the x properties to process</span>
    if isa(el,'LIST') then foreach props,self.xproperties,j do ((self.xproperties)[j])[i]=el[j] else begin
      case propagate of
       <span class="comments">;Do not propagate property</span>
       0 : currentx[i]=el
       <span class="comments">;Propagate property to all plots</span>
       1 : begin
         foreach props,self.xproperties,j do ((self.xproperties)[j])[i]=el
         to_update=hash(indgen(self.nlines*self.ncolumns),self.oplots)
       end
       <span class="comments">;Propagate property over the plot's column</span>
       2 : begin
         ((self.xproperties)[column])[i]=el
         to_update[column+indgen(self.nlines)*self.ncolumns]=(self.oplots)[column+indgen(self.nlines)*self.ncolumns]
       end
     endcase  
    endelse
  endif
  if currenty.haskey(i) then begin <span class="comments">;If it is one of the y properties to process</span>
    if isa(el,'LIST') then foreach props,self.yproperties,j do ((self.yproperties)[j])[i]=el[j] else begin
      case propagate of
       <span class="comments">;Do not propagate property</span>
       0 : currenty[i]=el
       <span class="comments">;Propagate property to all plots</span>
       1 : begin
         foreach props,self.yproperties,j do ((self.yproperties)[j])[i]=el
         to_update=hash(indgen(self.nlines*self.ncolumns),self.oplots)
       end
       <span class="comments">;Propagate property over the plot's line</span>
       2 : begin
         ((self.yproperties)[line])[i]=el
         to_update[line*self.ncolumns+indgen(self.ncolumns)]=(self.oplots)[line*self.ncolumns:(line+1)*self.ncolumns-1]
       end
     endcase  
    endelse
  endif  
endforeach

<span class="comments">;Update the properties in the plot objects where it is necessary</span>
foreach el,to_update,i do if isa(el) then $
 el.setproperty,_extra=(((self.xproperties)[i mod self.ncolumns])+((self.yproperties)[i/self.ncolumns])).tostruct()
 
<span class="comments">;Prepare the new extras, which includes the x/y properties for that plot, and the other (untouched) properties</span>

ret=extras[*]
foreach el,(self.xproperties)[column],i do if isa(el) then ret[i]=el
foreach el,(self.yproperties)[line],i do if isa(el) then ret[i]=el

return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Processes the extra parameters passed to `pp_multiplot::getproperty` and</span>
<span class="comments">;    `pp_multiplot::setproperty`, to pick those that specify axes properties.</span>
<span class="comments">;    Axes properties are given a special treatment, as they might be kept</span>
<span class="comments">;    synchronized across lines/column/all plots.</span>
<span class="comments">;    </span>
<span class="comments">;  :Hidden: This routine is to be used only by `pp_multiplot::getproperty` and </span>
<span class="comments">;  `pp_multiplot::setproperty`.</span>
<span class="comments">;  </span>
<span class="comments">;  :Private: This routine is to be used only by `pp_multiplot::getproperty` and </span>
<span class="comments">;  `pp_multiplot::setproperty`.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    extras: in, required</span>
<span class="comments">;      Extra parameters that were passed to the caller, converted to a hash, to be</span>
<span class="comments">;      processed here.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    get: out, optional</span>
<span class="comments">;      If provided, a variable where the values of the x/y properties that were</span>
<span class="comments">;      processed here are returned.</span>
<span class="comments">;    set: out, optional</span>
<span class="comments">;      This informs whether this routine encountered and processed any x/y properties,</span>
<span class="comments">;      so that `pp_multiplot::setproperty` can know that an update on plot properties</span>
<span class="comments">;      might be needed.</span>
<span class="comments">;      </span>
<span class="comments">;      The other keywords present here are the x/y properties that this routine processes,</span>
<span class="comments">;      and which must be present in the argument list so that their values can be passed</span>
<span class="comments">;      back trough `pp_multiplot::getproperty`, due to the way _ref_extra works.</span>
<span class="comments">;      </span>
<span class="comments">; :Returns:</span>
<span class="comments">;   A hash of the properties that were not processed here, which should be passed</span>
<span class="comments">;   on to the call of window's get/set property.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="pp_multiplot::process_extras_properties:source"></a>function pp_multiplot::process_extras_properties,extras,get=get,set=set,$
  XCOLOR=xcolor,XGRIDSTYLE=xgridstyle,XLOG=xlog,XMAJOR=xmajor,XMINOR=xminor,XSUBTICKLEN=xsubticklen,$
  XTEXT_COLOR=xtext_color,XTEXT_POS=xtext_pos,XTHICK=xthick,XTICKDIR=xtickdir,XTICKFONT_NAME=xtickfont_NAME,$
  XTICKFONT_SIZE=xtickfont_size,XTICKFONT_STYLE=xtickfont_style,XTICKFORMAT=xtickformat,$
  XTICKINTERVAL=xtickinterval,XTICKLAYOUT=xticklayout,XTICKLEN=xticklen,XTICKNAME=xtickname,$
  XTICKUNITS=xtickunits,XTICKVALUES=xtickvalues,XTITLE=xtitle,XTRANSPARENCY=xtransparency,$
  YCOLOR=ycolor,YGRIDSTYLE=ygridstyle,YLOG=ylog,YMAJOR=ymajor,YMINOR=yminor,YSUBTICKLEN=ysubticklen,$
  YTEXT_COLOR=ytext_color,YTEXT_POS=ytext_pos,YTHICK=ythick,YTICKDIR=ytickdir,YTICKFONT_NAME=ytickfont_name,$
  YTICKFONT_SIZE=ytickfont_size,YTICKFONT_STYLE=ytickfont_style,YTICKFORMAT=ytickformat,$
  YTICKINTERVAL=ytickinterval,YTICKLAYOUT=yticklayout,YTICKLEN=yticklen,YTICKNAME=ytickname,$
  YTICKUNITS=ytickunits,YTICKVALUES=ytickvalues,YTITLE=ytitle,YTRANSPARENCY=ytransparency
compile_opt idl2, logical_predicate,hidden

retr=arg_present(get)
if retr then get=hash() else begin
  oldx=list()
  foreach column,self.xproperties,i do oldx.add,column[*]
  oldy=list()
  foreach column,self.yproperties,i do oldy.add,column[*]
endelse
set=0

if (n_elements(extras) eq 0) then return,hash() <span class="comments">;Get out if there is nothing to process</span>

foreach value,extras,key do begin
  if ((self.xproperties)[0]).haskey(key) then begin
    set=1
    extras.remove,key
    if retr then begin<span class="comments">;If properties are being retrieved</span>
      get[key]=list()
      foreach column,self.xproperties do (get[key]).add,column[key]
    endif else begin <span class="comments">;If properties are being set</span>
      if (n_elements(value) eq self.ncolumns) && isa(value,'LIST') then $
       foreach el,value,i do ((self.xproperties)[i])[key]=el else $ <span class="comments">;If a list was provided</span>
       foreach el,self.xproperties do el[key]=value <span class="comments">;If a single value must be replicated for all columns</span>
    endelse
  endif
  if ((self.yproperties)[0]).haskey(key) then begin
    set=1
    extras.remove,key
    if retr then begin<span class="comments">;If properties are being retrieved</span>
      get[key]=list()
      foreach column,self.yproperties do (get[key]).add,column[key]
    endif else begin <span class="comments">;If properties are being set</span>
      if (n_elements(value) eq self.nlines) && isa(value,'LIST') then $
       foreach el,value,i do ((self.yproperties)[i])[key]=el else $ <span class="comments">;If a list was provided</span>
       foreach el,self.yproperties do el[key]=value <span class="comments">;If a single value must be replicated for all lines</span>
    endelse
  endif
endforeach

<span class="comments">;Update any properties that have changed</span>
if ~retr then begin
  foreach el,self.xproperties,column do if (el ne oldx[column]) then $
   foreach opl,(self.oplots)[indgen(self.nlines)*self.ncolumns+column] do $
   opl.setproperty,_extra=el.tostruct()
  foreach el,self.yproperties,line do if (el ne oldy[line]) then $
   foreach opl,(self.oplots)[indgen(self.ncolumns)+(self.ncolumns*line)] do $
   opl.setproperty,_extra=el.tostruct()
endif

<span class="comments">;Send the retrieved properties back</span>
if retr then begin
  if arg_present(xcolor) then xcolor=get['XCOLOR']
  if arg_present(xgridstyle) then xgridstyle=get['XGRIDSTYLE']
  if arg_present(xlog) then xlog=get['XLOG']
  if arg_present(xmajor) then xmajor=get['XMAJOR']
  if arg_present(xminor) then xminor=get['XMINOR']
  if arg_present(xsubticklen) then xsubticklen=get['XSUBTICKLEN']
  if arg_present(xtext_color) then xtext_color=get['XTEXT_COLOR']
  if arg_present(xtext_pos) then xtext_pos=get['XTEXT_POS']
  if arg_present(xthick) then xthick=get['XTHICK']
  if arg_present(xtickdir) then xtickdir=get['XTICKDIR']
  if arg_present(xtickfont_name) then xtickfont_name=get['XTICKFONT_NAME']
  if arg_present(xtickfont_size) then xtickfont_size=get['XTICKFONT_SIZE']
  if arg_present(xtickfont_style) then xtickfont_style=get['XTICKFONT_STYLE']
  if arg_present(xtickformat) then xtickformat=get['XTICKFORMAT']
  if arg_present(xtickinterval) then xticklayout=get['XTICKLAYOUT']
  if arg_present(xticklayout) then xticklayout=get['XTICKLAYOUT']
  if arg_present(xticklen) then xticklen=get['XTICKLEN']
  if arg_present(xtickname) then xtickname=get['XTICKNAME']
  if arg_present(xtickunits) then xtickunits=get['XTICKUNITS']
  if arg_present(xtickvalues) then xtickvalues=get['XTICKVALUES']
  if arg_present(xtitle) then xtitle=get['XTITLE']
  if arg_present(xtransparency) then xtransparency=get['XTRANSPARENCY']
  
  if arg_present(ycolor) then ycolor=get['YCOLOR']
  if arg_present(ygridstyle) then ygridstyle=get['YGRIDSTYLE']
  if arg_present(ylog) then ylog=get['YLOG']
  if arg_present(ymajor) then ymajor=get['YMAJOR']
  if arg_present(yminor) then yminor=get['YMINOR']
  if arg_present(ysubticklen) then ysubticklen=get['YSUBTICKLEN']
  if arg_present(ytext_color) then ytext_color=get['YTEXT_COLOR']
  if arg_present(ytext_pos) then ytext_pos=get['YTEXT_POS']
  if arg_present(ythick) then ythick=get['YTHICK']
  if arg_present(ytickdir) then ytickdir=get['YTICKDIR']
  if arg_present(ytickfont_name) then ytickfont_name=get['YTICKFONT_NAME']
  if arg_present(ytickfont_size) then ytickfont_size=get['YTICKFONT_SIZE']
  if arg_present(ytickfont_style) then ytickfont_style=get['YTICKFONT_STYLE']
  if arg_present(ytickformat) then ytickformat=get['YTICKFORMAT']
  if arg_present(ytickinterval) then yticklayout=get['YTICKLAYOUT']
  if arg_present(yticklayout) then yticklayout=get['YTICKLAYOUT']
  if arg_present(yticklen) then yticklen=get['YTICKLEN']
  if arg_present(ytickname) then ytickname=get['YTICKNAME']
  if arg_present(ytickunits) then ytickunits=get['YTICKUNITS']
  if arg_present(ytickvalues) then ytickvalues=get['YTICKVALUES']
  if arg_present(ytitle) then ytitle=get['YTITLE']
  if arg_present(ytransparency) then ytransparency=get['YTRANSPARENCY']
endif

ret=extras[*]
return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Updates the tick labels in the given plot object, to suppress the first, last</span>
<span class="comments">;    or both tick labels in the plot.</span>
<span class="comments">;    </span>
<span class="comments">;  :Hidden: This routine is to be used only by methods of `pp_multiplot`.</span>
<span class="comments">;  </span>
<span class="comments">;  :Private: This routine is to be used only by methods of `pp_multiplot`.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    endticks: in, required</span>
<span class="comments">;      The mode to use for tick suppression. Like in `pp_plot`, 1 suppresses only</span>
<span class="comments">;      the last tick, 2 suppresses only the first tick, and 0 suppresses both.</span>
<span class="comments">;    opl: in, required</span>
<span class="comments">;      The plot object to act upon when updating the tick labels.</span>
<span class="comments">;    ax: in, required</span>
<span class="comments">;      The axis to act upon in the given plot object: 'x' or 'y'</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="pp_multiplot::setendticks:source"></a>pro pp_multiplot::setendticks,endticks,opl,ax
compile_opt idl2,logical_predicate,hidden

<span class="comments">;If necessary, revise x/yendticks</span>
if (ax eq 'x') && (endticks eq 1) then begin
  xr=opl.xrange
  xtv=opl.xtickv
  nt=n_elements(xtv)
  ti=abs(xtv[-1]-xtv[-2])
  if ((abs(xr[1]-xtv[-1]))&lt;(abs(xr[1]-xtv[0]))) gt self.xtickratio*ti*(nt/3d0) then endticks=3
endif
if (ax eq 'y') && (endticks eq 1) then begin
  xr=opl.yrange
  xtv=opl.ytickv
  nt=n_elements(xtv)
  ti=abs(xtv[-1]-xtv[-2])
  if ((abs(xr[1]-xtv[-1]))&lt;(abs(xr[1]-xtv[0]))) gt self.ytickratio*ti*(nt/3d0) then endticks=3
endif


if (endticks ne 3) then begin
  axes=opl[ax+'axis']
  if axes eq obj_new() then axes=[]
  foreach el, axes do if isa(el.tickname) then begin
    tn=el.tickname
    range=ax eq 'x' ? el.xrange : el.yrange
    if range[1] ge range[0] then begin
      r0=0 & r1=-1
    endif else begin
      r0=-1 & r1=0
    endelse
    if ((endticks eq 0)||(endticks eq 2)) then tn[r0]=''
    if ((endticks eq 0)||(endticks eq 1)) then tn[r1]=''
    el.tickname=tn
  endif
endif
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Calculates the position parameters for a plot in the grid, given its index,</span>
<span class="comments">;    and the parameters set in the fields of self. For use of plot objects, use</span>
<span class="comments">;    `pp_multiplot::plot` directly, which already uses this method to compute the</span>
<span class="comments">;    location in the grid. This method can be useful if one wants to add another</span>
<span class="comments">;    type of Graphic (not a plot object) into the grid, such as an image or a contour.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    mindex: in, required</span>
<span class="comments">;      The grid index of the plot being created, from 0 to ncolumns*nlines-1. </span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    bottom: out</span>
<span class="comments">;      Indicates whether this plot is in the bottom line of the grid.</span>
<span class="comments">;    left: out</span>
<span class="comments">;      Indicates whether this plot is in the left column of the grid.</span>
<span class="comments">;    top: out</span>
<span class="comments">;      Indicates whether this plot is in the top line of the grid.</span>
<span class="comments">;    right: out</span>
<span class="comments">;      Indicates whether this plot is in the right column of the grid.</span>
<span class="comments">;    column: out</span>
<span class="comments">;      The column where this plot lies on the grid (starting from 0).</span>
<span class="comments">;    line: out</span>
<span class="comments">;      The line where this plot lies on the grid (starting from 0).</span>
<span class="comments">;</span>
<span class="comments">;  :Returns:</span>
<span class="comments">;    The position array to be passed on to plot, to create this plot on the proper</span>
<span class="comments">;    place in the multiplot window. Contains [x0,y0,x1,y1], where the first two</span>
<span class="comments">;    refer to the lower-left corner, and the last two refer to the top-right corner,</span>
<span class="comments">;    with x counting from the left, and y counting from the bottom.</span>
<span class="comments">;-</span>
<a id="pp_multiplot::getposition:source"></a>function pp_multiplot::getposition,mindex,bottom=bottom,left=left,top=top,right=right,$
 column=column,line=line
compile_opt idl2,logical_predicate
<span class="comments">;Determine the location for the plot</span>
column=mindex mod self.ncolumns
line=mindex/self.ncolumns
<span class="comments">;Parameters that determine if the axes labels are going to be drawn</span>
left=column eq 0 <span class="comments">;Is this plot on the left column?</span>
right=column eq (self.ncolumns-1) <span class="comments">;Is this plot on the right column?</span>
bottom=line eq (self.nlines-1) <span class="comments">;Is this plot on the bottom line?</span>
top=line eq 0 <span class="comments">;Is this plot on the bottom line?</span>
fullwidth=1d0-self.global_margin[0]-self.global_margin[2]
fullheight=1d0-self.global_margin[1]-self.global_margin[3]
shiftsx=self.global_margin[0]+([0d0,total(self.cwidths.toarray(),/cumulative)])*fullwidth
shiftsy=self.global_margin[1]+(1d0-[0d0,total(self.lheights.toarray(),/cumulative)])*fullheight
return,[shiftsx[column]+(left ? 0d0 : self.xgap/2d0),shiftsy[line+1]+(bottom ? 0d0 : self.ygap/2d0),$
  shiftsx[column+1]-(right ? 0d0 : self.xgap/2d0),shiftsy[line]-(top ? 0d0 : self.ygap/2d0)]

end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Retrieves properties from pp_multiplot objects. Since pp_multiplot inherits</span>
<span class="comments">;    from IDL_Object, these properties can be accessed with the dot (.) operator.</span>
<span class="comments">;    The extra properties not handled here are passed on to the getproperty method</span>
<span class="comments">;    of the window object (which contains the plots). </span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    multi_layout: out, optional</span>
<span class="comments">;      The layout of the grid, as a 2-element array with the number of</span>
<span class="comments">;      columns and the number of lines for the grid.</span>
<span class="comments">;    global_xtitle: out, optional</span>
<span class="comments">;      The common title for all the x axes.</span>
<span class="comments">;    global_ytitle: out, optional</span>
<span class="comments">;      The common title for all the y axes.</span>
<span class="comments">;    global_margin: out, optional</span>
<span class="comments">;      The margins, in normalized units (range 0 to 1) around the grid. Returned</span>
<span class="comments">;      as a 4-element array, for [left, bottom, right, top] margins.</span>
<span class="comments">;    window: out, optional</span>
<span class="comments">;      The window object, which contains the plots.</span>
<span class="comments">;    title: out, optional</span>
<span class="comments">;      The title for the entire plot (which resides in the window object).</span>
<span class="comments">;    xranges: out, optional</span>
<span class="comments">;      A list, with one element for each column, each being a 2-element array</span>
<span class="comments">;      with the minimum and maximum of the x axes for the plots on each column.    </span>
<span class="comments">;    yranges: out,optional</span>
<span class="comments">;      A list, with one element for each line, each being a 2-element array</span>
<span class="comments">;      with the minimum and maximum of the y axes for the plots on each line.    </span>
<span class="comments">;    xproperties: out,optional</span>
<span class="comments">;      A list, with one element for each column, each being a hash with the x</span>
<span class="comments">;      axes' properties that have been set for the plots on each column. On columns</span>
<span class="comments">;      with no properties set, the hash is empty.</span>
<span class="comments">;    yproperties: out,optional</span>
<span class="comments">;      A list, with one element for each line, each being a hash with the y</span>
<span class="comments">;      axes' properties that have been set for the plots on each line. On lines</span>
<span class="comments">;      with no properties set, the hash is empty.</span>
<span class="comments">;    xendticks: out, optional</span>
<span class="comments">;      A list, with one element for each column, each being the mode set for</span>
<span class="comments">;      suppressing the first/last x tick labels of the corresponding plot: 0</span>
<span class="comments">;      means that both the first and last labels are suppressed, 1 means that only</span>
<span class="comments">;      the last label is suppressed, 2 means that only the first label is suppressed,</span>
<span class="comments">;      and 3 means that neither is suppressed. The default for each plot depends</span>
<span class="comments">;      on its location on the multiplot grid (its mindex): Plots have their last</span>
<span class="comments">;      label suppressed (xendticks=1), except for those that fall on the rightmost</span>
<span class="comments">;      column (xendticks=3).</span>
<span class="comments">;    yendticks: out, optional</span>
<span class="comments">;      A list, with one element for each column, each being the mode set for</span>
<span class="comments">;      suppressing the first/last y tick labels of the corresponding plot: 0</span>
<span class="comments">;      means that both the first and last labels are suppressed, 1 means that only</span>
<span class="comments">;      the last label is suppressed, 2 means that only the first label is suppressed,</span>
<span class="comments">;      and 3 means that neither is suppressed. The default for each plot depends</span>
<span class="comments">;      on its location on the multiplot grid (its mindex): Plots have their last</span>
<span class="comments">;      label suppressed (yendticks=1), except for those that fall on the top</span>
<span class="comments">;      line (yendticks=3).</span>
<span class="comments">;    _ref_extra: out, optional</span>
<span class="comments">;      Any keywords not handled by this method are passed on to the getproperty</span>
<span class="comments">;      method of the window object. See the help on window objects for details.</span>
<span class="comments">;      </span>
<span class="comments">;      The following properties are axes properties, that can be made common across</span>
<span class="comments">;      columns (x) or lines (y). They are from the plot objects, and are returned</span>
<span class="comments">;      as a list, with one element for each column (x) or line (y). See the help</span>
<span class="comments">;      on plot objects for details:</span>
<span class="comments">;      </span>
<span class="comments">;      [XY]COLOR, [XY]GRIDSTYLE, [XY]LOG, [XY]MAJOR, [XY]MINOR, [XY]SUBTICKLEN, [XY]TEXT_COLOR, </span>
<span class="comments">;      [XY]TEXT_POS, [XY]THICK, [XY]TICKDIR, [XY]TICKFONT_NAME, [XY]TICKFONT_SIZE, [XY]TICKFONT_STYLE, </span>
<span class="comments">;      [XY]TICKFORMAT, [XY]TICKINTERVAL, [XY]TICKLAYOUT, [XY]TICKLEN, [XY]TICKNAME, [XY]TICKUNITS, </span>
<span class="comments">;      [XY]TICKVALUES, [XY]TITLE, [XY]TRANSPARENCY</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="pp_multiplot::getproperty:source"></a>pro pp_multiplot::getproperty,_ref_extra=ex,$
 multi_layout=mlayout,global_xtitle=gxtitle,global_ytitle=gytitle,$
 global_margin=gmargin,window=owindow,$
 title=otitle,xranges=xranges,yranges=yranges,$
 xproperties=xproperties,yproperties=yproperties,xendticks=xendticks,yendticks=yendticks,$
 xgap=xgap,ygap=ygap
compile_opt idl2, logical_predicate
if arg_present(gxtitle) then gxtitle=self.global_xtitle
if arg_present(gytitle) then gytitle=self.global_ytitle
if arg_present(gmargin) then gmargin=self.global_margin
if arg_present(mlayout) then mlayout=self.mlayout
if arg_present(owindow) then owindow=self.owindow
if arg_present(xranges) then xranges=(self.xranges)[*]
if arg_present(yranges) then yranges=(self.yranges)[*]
if arg_present(xendticks) then xendticks=(self.xendticks)[*]
if arg_present(yendticks) then yendticks=(self.yendticks)[*]
<span class="comments">;Return only the x/y properties that have been set</span>
if arg_present(xproperties) then xproperties=(self.xproperties)[where(self.xproperties ne !null)]
if arg_present(yproperties) then yproperties=(self.yproperties)[where(self.yproperties ne !null)]
if arg_present(xgap) then xgap=self.xgap
if arg_present(ygap) then ygap=self.ygap

<span class="comments">;Filter and process the [x/y]properties from the extras</span>
extras=hash(ex)
ex=self.process_extras_properties(extras,get=props,_extra=ex)
ex=(ex.keys()).toarray() <span class="comments">;Extras to pass on</span>

<span class="comments">;Get all other properties from the window object</span>
<span class="comments">;This block is to provide the right title object, due to a bug in IDL 8.0's igetid that breaks title in window objects.</span>
if arg_present(otitle) then begin
  tool=self.owindow.gettool()
  id=tool.findidentifiers('*TITLE')
  otitle=tool.getbyidentifier(id)
endif
if (n_elements(ex) ne 0) then self.owindow.getproperty,_extra=ex

end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Sets properties for pp_multiplot objects. Since pp_multiplot inherits</span>
<span class="comments">;    from IDL_Object, these properties can be accessed with the dot (.) operator.</span>
<span class="comments">;    The extra properties not handled here are passed on to the setproperty method</span>
<span class="comments">;    of the window object (which contains the plots). </span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    global_xtitle: in, optional</span>
<span class="comments">;      The common title for all the x axes.</span>
<span class="comments">;    global_ytitle: in, optional</span>
<span class="comments">;      The common title for all the y axes.</span>
<span class="comments">;    title: in, optional</span>
<span class="comments">;      The title for the entire plot (which resides in the window object).</span>
<span class="comments">;    xranges: in, optional</span>
<span class="comments">;      The minimum and maximum of the x axes for the plots on each column. Provided</span>
<span class="comments">;      as either a list, with one element for each column, each being a 2-element</span>
<span class="comments">;      array, or a 2-element array, to be applied for all columns, or as a [2,ncolumns]</span>
<span class="comments">;      array, with the minimum and maximum for each column.    </span>
<span class="comments">;    yranges: in,optional</span>
<span class="comments">;      The minimum and maximum of the y axes for the plots on each line. Provided</span>
<span class="comments">;      as either a list, with one element for each line, each being a 2-element</span>
<span class="comments">;      array, or a 2-element array, to be applied for all lines, or as a [2,nlines]</span>
<span class="comments">;      array, with the minimum and maximum for each line.</span>
<span class="comments">;    xproperties: in,optional</span>
<span class="comments">;      The x axes' properties that are set for the plots on each column. Provided</span>
<span class="comments">;      as either a list, with one element for each column, each being a hash with</span>
<span class="comments">;      the properties/values as keys/values, or a single hash, to be applied for</span>
<span class="comments">;      all columns.     </span>
<span class="comments">;    yproperties: in,optional</span>
<span class="comments">;      The y axes' properties that are set for the plots on each line. Provided</span>
<span class="comments">;      as either a list, with one element for each line, each being a hash with</span>
<span class="comments">;      the properties/values as keys/values, or a single hash, to be applied for</span>
<span class="comments">;      all lines.</span>
<span class="comments">;    xendticks: in, optional</span>
<span class="comments">;     The modes for suppressing the first/last x tick labels of the corresponding</span>
<span class="comments">;     plots: 0 means that both the first and last labels are suppressed, 1 means</span>
<span class="comments">;     that only the last label is suppressed, 2 means that only the first label</span>
<span class="comments">;     is suppressed, and 3 means that neither is suppressed. Provided as either</span>
<span class="comments">;     a nlines*ncolumns array, with one element for each plot, or as a scalar, to</span>
<span class="comments">;     be applied the same for all plots. </span>
<span class="comments">;    yendticks: in, optional</span>
<span class="comments">;     The modes for suppressing the first/last y tick labels of the corresponding</span>
<span class="comments">;     plots: 0 means that both the first and last labels are suppressed, 1 means</span>
<span class="comments">;     that only the last label is suppressed, 2 means that only the first label</span>
<span class="comments">;     is suppressed, and 3 means that neither is suppressed. Provided as either</span>
<span class="comments">;     a nlines*ncolumns array, with one element for each plot, or as a scalar, to</span>
<span class="comments">;     be applied the same for all plots.</span>
<span class="comments">;    _extra: in, optional</span>
<span class="comments">;      Any keywords not handled by this method are passed on to the getproperty</span>
<span class="comments">;      method of the window object. See the help on window objects for details.</span>
<span class="comments">;      </span>
<span class="comments">;      The following properties are axes properties, that can be made common across</span>
<span class="comments">;      columns (x) or lines (y). They are for the plot objects, and are set</span>
<span class="comments">;      as either a list, with one element for each column (x) or line (y), or a</span>
<span class="comments">;      single property, to be replicated for all plots in the column/line. See</span>
<span class="comments">;      the help on plot objects for details:</span>
<span class="comments">;      </span>
<span class="comments">;      [XY]COLOR, [XY]GRIDSTYLE, [XY]LOG, [XY]MAJOR, [XY]MINOR, [XY]SUBTICKLEN, [XY]TEXT_COLOR, </span>
<span class="comments">;      [XY]TEXT_POS, [XY]THICK, [XY]TICKDIR, [XY]TICKFONT_NAME, [XY]TICKFONT_SIZE, [XY]TICKFONT_STYLE, </span>
<span class="comments">;      [XY]TICKFORMAT, [XY]TICKINTERVAL, [XY]TICKLAYOUT, [XY]TICKLEN, [XY]TICKNAME, [XY]TICKUNITS, </span>
<span class="comments">;      [XY]TICKVALUES, [XY]TITLE, [XY]TRANSPARENCY</span>
<span class="comments">;      </span>
<span class="comments">;-</span>
<a id="pp_multiplot::setproperty:source"></a>pro pp_multiplot::setproperty,_extra=ex,$
 global_xtitle=gxtitle,global_ytitle=gytitle,$
 title=title,xranges=xranges,yranges=yranges,$
 xproperties=xproperties,yproperties=yproperties,xendticks=xendticks,yendticks=yendticks,$
 xgap=xgap,ygap=ygap
compile_opt idl2, logical_predicate
if (n_elements(gxtitle) ne 0) then begin <span class="comments">;Set the global x title</span>
  if obj_valid(self.global_xtitle) then self.global_xtitle.string=gxtitle else begin
    self.owindow.select,/clear <span class="comments">;Just to make this window the current one</span>
    self.global_xtitle=text(0.5,0.025,gxtitle,alignment=0.5)
  endelse
endif
if (n_elements(gytitle) ne 0) then begin <span class="comments">;Set the global y title</span>
  if obj_valid(self.global_ytitle) then self.global_ytitle.string=gytitle else begin
    self.owindow.select,/clear <span class="comments">;Just to make this window the current one</span>
    self.global_ytitle=text(0.05,0.5,gytitle,alignment=0.5,baseline=[0.,1.0,0.],updir=[-1.,0.,0.])
  endelse
endif

<span class="comments">;Set [xy]ranges</span>
if ((n_elements(xranges) eq self.ncolumns) && isa(xranges,'list')) then self.xranges=xranges[*]
if (n_elements(xranges) eq 2*self.ncolumns) then for i=0,self.ncolumns-1 do (self.xranges)[i]=xranges[*,i]
if ((n_elements(xranges) eq 2) && (~isa(xranges,'list'))) then for i=0,self.ncolumns-1 do (self.xranges)[i]=xranges
<span class="comments">;Update ranges if necessary</span>
if (n_elements(xranges) ne 0) then foreach el,self.oplots,i do if isa(el) then begin
  column=i mod self.ncolumns
  if ~array_equal(el.xrange,xranges[column]) then begin
    el.xrange=(self.xranges)[column]
    self.setendticks,(self.xendticks)[i],el,'x'
    self.setendticks,(self.yendticks)[i],el,'y'
  endif
endif

if ((n_elements(yranges) eq self.nlines) && isa(yranges,'list')) then self.yranges=yranges[*]
if (n_elements(yranges) eq 2*self.nlines) then for i=0,self.nlines-1 do (self.yranges)[i]=yranges[*,i]
if ((n_elements(yranges) eq 2) && (~isa(yranges,'list'))) then for i=0,self.nlines-1 do self.yranges[i]=yranges
if (n_elements(yranges) ne 0) then foreach el,self.oplots,i do if isa(el) then el.yrange=(self.yranges)[i/self.ncolumns] 
<span class="comments">;Update ranges if necessary</span>
if (n_elements(yranges) ne 0) then foreach el,self.oplots,i do if isa(el) then begin
  line=i/self.ncolumns
  if ~array_equal(el.yrange,yranges[line]) then begin
    el.yrange=(self.yranges)[line]
    self.setendticks,(self.xendticks)[i],el,'x'
    self.setendticks,(self.yendticks)[i],el,'y'
  endif
endif

<span class="comments">;Set [xy]endticks</span>
oldxendticks=(self.xendticks)[*]
if (n_elements(xendticks) eq self.ncolumns*self.nlines) then (self.xendticks)[*]=xendticks[*]
if ((n_elements(xendticks) eq 1) && (~isa(xendticks,'list'))) then (self.xendticks)[*]=xendticks
<span class="comments">;Update ranges if necessary</span>
if (n_elements(xendticks) ne 0) then begin
  w=where(self.xendticks ne oldxendticks,/null)
  foreach el,(self.oplots)[w],i do if isa(el) then begin
    self.setendticks,(self.xendticks)[i],el,'x'
  endif
endif

oldyendticks=(self.yendticks)[*]
if (n_elements(yendticks) eq self.ncolumns*self.nlines) then (self.yendticks)[*]=yendticks[*]
if ((n_elements(yendticks) eq 1) && (~isa(yendticks,'list'))) then (self.yendticks)[*]=yendticks
<span class="comments">;Update ranges if necessary</span>
if (n_elements(yendticks) ne 0) then begin
  w=where(self.yendticks ne oldyendticks,/null)
  foreach el,(self.oplots)[w],i do if isa(el) then begin
    self.setendticks,(self.yendticks)[i],el,'y'
  endif
endif


<span class="comments">;Set [xy]properties</span>
oldx=list()
foreach column,self.xproperties,i do oldx.add,column[*]
oldy=list()
foreach column,self.yproperties,i do oldy.add,column[*]

<span class="comments">;Filter and process the [x/y]properties from the extras</span>
<span class="comments">;Get around bug in IDL 8.0's hash init()</span>
extras=hash() & if (n_elements(ex) ne 0) then begin
  tn=tag_names(ex)
  for i=0,n_tags(ex)-1 do extras[tn[i]]=ex.(i)
endif
ex=self.process_extras_properties(extras,set=set)
ex=ex.tostruct() <span class="comments">;Extras to pass on</span>

<span class="comments">;If the properties were provided in a list (one element per column/line)</span>
if ((n_elements(xproperties) eq self.ncolumns) && isa(xproperties,'list')) then $
 foreach el,xproperties,i do (self.xproperties)[i]=el
if ((n_elements(yproperties) eq self.nlines) && isa(yproperties,'list')) then $
 foreach el,yproperties,i do (self.yproperties)[i]=el
<span class="comments">;If the properties were provided in a hash (same properties for all columns/lines)</span>
if (n_elements(xproperties) eq 1) && isa(xproperties,'hash') then foreach el,self.xproperties do el+=xproperties
if (n_elements(yproperties) eq 1) && isa(yproperties,'hash') then foreach el,self.yproperties do el+=yproperties 
<span class="comments">;Update properties if necessary</span>
if (n_elements(xproperties) ne 0)||(n_elements(yproperties) ne 0)||set then $
 foreach el,self.oplots,i do if isa(el) then begin
  column=i mod self.ncolumns
  line=i/self.ncolumns
  if ((self.xproperties)[column] ne oldx[column]) or ((self.yproperties)[line] ne oldy[line]) then $
   el.setproperty,_extra=((self.xproperties)[column]+(self.yproperties)[line]).tostruct()
end



<span class="comments">;Pass on all other properties to the window object</span>
<span class="comments">;The following block is to avoid window's title property, which is broken in IDL 8.0</span>
if (n_elements(title) ne 0) then begin
  self.getproperty,title=otitle
  if ~isa(oTitle) then $ <span class="comments">;Make a title if there is none</span>
   itext,title,target=self.owindow->getfullidentifier(),/title else $
   otitle.setproperty,string=title <span class="comments">;Or just change the title's string if there a title already</span>
   otitle.updatescene
endif
if (n_elements(ex) ne 0) then self.owindow.setproperty,_extra=ex

end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Synchronizes the axes, across a line and column, or over the whole grid,</span>
<span class="comments">;    so that they have the same x/y ranges, and, optionally, the same set</span>
<span class="comments">;    x/y axes properties.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    mindex: in, optional</span>
<span class="comments">;      If provided, uses the plot at position mindex (count starts from 0) as the</span>
<span class="comments">;      reference for the axes. If not provided, the currently selected plot is used.</span>
<span class="comments">;      If the index is not provided and none are selected, the first valid plot</span>
<span class="comments">;      is used.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    layout: in, optional, default=0</span>
<span class="comments">;      If set, not only the ranges are synchronized, but also the x/y axes layouts,</span>
<span class="comments">;      from those properties that have been set (in xproperties and xyproperties).</span>
<span class="comments">;    all: in, optional, default=0</span>
<span class="comments">;      If set, synchronization is carried out on all plots in the grid, instead of</span>
<span class="comments">;      only to those at the same line and same column as the plot used as reference.</span>
<span class="comments">;      </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the documentation on the method `pp_multiplot::plot` for examples.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="pp_multiplot::sync_axes:source"></a>pro pp_multiplot::sync_axes,mindex,layout=layout,all=all
compile_opt idl2, logical_predicate

<span class="comments">;Defaults</span>
layout=n_elements(layout) eq 1 ? layout : 0
all=n_elements(all) eq 1 ? all : 0

if (n_elements(mindex) ne 1) then begin <span class="comments">;Get the ranges from the current plot</span>
  sel=self.owindow.getselecteditems()
  if isa(sel) then begin
    sel.getproperty,xrange=xr,yrange=yr
    dss=(sel.getdataspace()).getfullidentifier()+'/'
    foreach el,self.oplots,i do if isa(el) then begin
      ds=stregex(el.getfullidentifier(),'.*(/DATA SPACE).*/',/extract)
      if dss eq ds then break
    endif
    mindex=i
  endif
endif
if (n_elements(mindex) eq 0) then mindex=0
<span class="comments">;Get the ranges from the given index</span>
mindex=0>mindex&lt;(self.ncolumns*self.nlines-1)
column=mindex mod self.ncolumns
line=mindex/self.ncolumns
print,'sync_axes: Updating axes to those of index '+strtrim(mindex,2)
if (n_elements(mindex) eq 1) then begin
  if isa((self.oplots)[mindex]) then begin
    xr=((self.oplots)[mindex]).xrange
    yr=((self.oplots)[mindex]).yrange
    self.setendticks,(self.xendticks)[mindex],(self.oplots)[mindex],'x'
    self.setendticks,(self.yendticks)[mindex],(self.oplots)[mindex],'y'
  endif else begin
    print,'sync_axes: Selected index does not yet contain a plot; doing nothing'
    return
  endelse
endif
<span class="comments">;Update the ranges</span>
newxranges=(self.xranges)[*]
newyranges=(self.yranges)[*]
if all then begin <span class="comments">;Sync all plots</span>
  newxranges[*]=xr
  newyranges[*]=yr  
endif else begin <span class="comments">;Sync only plots in the current line and column</span>
  newxranges[column]=xr
  newyranges[line]=yr
endelse
self.setproperty,xranges=newxranges,yranges=newyranges

<span class="comments">;Update the other properties, if this option was set</span>
if layout then begin
  props=(self.xproperties)[column]+(self.yproperties)[line]
  props=(props[where(props ne !null)]).tostruct()
  if (~all) then begin <span class="comments">;Sync only plots in the current line and column</span>
    to_update=hash(indgen(self.ncolumns)+self.ncolumns*line)
    to_update+=hash(indgen(self.nlines)*self.ncolumns+self.ncolumns*line)
    foreach el,(self.oplots)[(to_update.keys()).toarray()] do el.setproperty,_extra=props
  <span class="comments">;Sync all plots</span>
  endif else foreach el,self.oplots do if isa(el) then el.setproperty,_extra=props
endif

end

<a id="pp_multiplot::decideintervals:source"></a>pro pp_multiplot::decideintervals,dprange,dticks,dint,decide=decide,newrange=newrange,dminor=dminor,newdticks=newdticks<span class="comments">;New algorithm</span>
  compile_opt idl2,logical_predicate,hidden
  intervals=[2d0,1d0,1d0,0.5d0]<span class="comments">;,0.25d0] ;Possible interval multipliers to use</span>
  intrats=[0.2d0,0.1d0,1d0,0.5d0]<span class="comments">;,0.25d0] ;Possible normalized interval multipliers</span>
  minors=[4,10,10,5]
  nintervals=n_elements(intervals)
  ints=[6,5,4,3] <span class="comments">;Possible number of intervals</span>
  nints=n_elements(ints)
  mindiff=!values.d_infinity
  for i=0,nints-1 do begin <span class="comments">;Try every number of intervals, to find out which one gives nicer intervals</span>
    dints=double(dprange[1]-dprange[0])/ints[i]
    al=alog10(dints)
    dints=al ge 0d0 ? 1d1^((al mod 1)-1d0) : 1d1^(al mod 1)
    tmp=min(abs(dints-intrats),minloc)
    if ((tmp-mindiff) lt -(machar(/double)).eps) then begin
      mindiff=tmp
      minint=intervals[minloc]
      sints=ints[i]
      dint=intrats[minloc]*1d1^ceil(al)
      dminor=minors[minloc]
    endif
    <span class="comments">;print,ints[i],minint,tmp,sints,dint</span>
  endfor
  newrange=dint*[floor(dprange[0]/dint),ceil(dprange[1]/dint)]
  dticks=sints+1d0
  newdticks=(newrange[1]-newrange[0])/dint
end


<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    This method should be called after one or more plots in the multiplot had</span>
<span class="comments">;    its axes changed in a way that caused its ticks to be recomputed (setting the</span>
<span class="comments">;    range, for instance), so that the end ticks get fixed.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="pp_multiplot::updateranges:source"></a>pro pp_multiplot::updateranges,x=x,y=y
compile_opt idl2,logical_predicate

if keyword_set(x) then begin
  dint=0d0
  dticks=0
  xranges=(self.xranges)[*]
  foreach xr,xranges,ix do begin
    self.decideintervals,xr,dtick,dint,newrange=nr
    xranges[ix]=nr
  endforeach
  self.setproperty,xranges=xranges
endif

if keyword_set(x) then begin
  dint=0d0
  dticks=0
  xranges=(self.xranges)[*]
  foreach xr,xranges,ix do begin
    self.decideintervals,xr,dtick,dint,newrange=nr
    xranges[ix]=nr
  endforeach
  self.setproperty,yranges=yranges
endif

foreach el,self.oplots,iel do if isa(el) then begin
  el['yaxis'].tickname=''
  el['xaxis'].tickname=''
  self.setendticks,self.xendticks[iel],el,'x'
  self.setendticks,self.yendticks[iel],el,'y'
endif
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Simple wrapper for window::close, to make pp_multiplot objects</span>
<span class="comments">;    look almost like they inherited the window class they use. For more details,</span>
<span class="comments">;    see the help on the close method of IDL's Graphics.</span>
<span class="comments">;-</span>
<a id="pp_multiplot::close:source"></a>pro pp_multiplot::close
compile_opt idl2,logical_predicate
  self.owindow.close
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Simple wrapper for window::save, to make pp_multiplot objects</span>
<span class="comments">;    look almost like they inherited the window class they use. For more details,</span>
<span class="comments">;    see the help on the save method of IDL's Graphics.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    filename, in, required</span>
<span class="comments">;      Passed on to window::save, the name for the file to create. Its extension</span>
<span class="comments">;      determines the type of file to be produced. See the help window::save for</span>
<span class="comments">;      more details.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    _REF_EXTRA, in, out, optional</span>
<span class="comments">;      Any keywords are passed on, unaltered, to window::save. See the</span>
<span class="comments">;      help on the window::save for details.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), 2010</span>
<span class="comments">;-</span>
<a id="pp_multiplot::save:source"></a>pro pp_multiplot::save,filename, _REF_EXTRA=_extra
compile_opt idl2,logical_predicate
  self.owindow.save,filename, _strict_extra=_extra
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Class definition for `pp_multiplot`.  </span>
<span class="comments">;-</span>
<a id="pp_multiplot__define:source"></a>pro pp_multiplot__define
compile_opt idl2, logical_predicate
!null={pp_multiplot, inherits idl_object, $
 owindow:obj_new(),$ <span class="comments">;The window is contained, instead of inherited, because of the convoluted way window objects are initialized.</span>
 oplots:list(),$ <span class="comments">;Where the plots will be contained</span>
 cwidths:list(),lheights:list(),mlayout:intarr(2),ncolumns:0,nlines:0,$ <span class="comments">;Specify the grid shape</span>
 <span class="comments">;Global formatting</span>
 global_title:'', global_xtitle:obj_new(), global_ytitle:obj_new(),$
 global_margin:dblarr(4),$
 mindex:0,$ <span class="comments">;Current position in the grid (0 to nlines*ncolumns)</span>
 xranges:list(),yranges:list(),$ <span class="comments">;x/y ranges for each column/line in the grid</span>
 xproperties:list(),yproperties:list(),$ <span class="comments">;x/y axes roperties for each column/line in the grid</span>
 xendticks:list(),yendticks:list(),$ <span class="comments">;x/y endticks for each plot in the grid</span>
 xgap:0d0,ygap:0d0,$ <span class="comments">;x/y gap between plots</span>
 xsupressdivision:0B,ysupressdivision:0B,$ <span class="comments">;Supress the lines between plots in x/y</span>
 graphproperties:obj_new(),$ <span class="comments">;Default properties for individual graphs</span>
 xtickratio:0d0,ytickratio:0d0}<span class="comments">;Parameter to decide if the last tick on an axis should not be auto suppressed</span>
end
</code>
    </div>
  </body>
</html>