<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue May 16 12:42:23 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>al_legend_pp.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="al_legend_pp.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'IDL preformatted' </span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       AL_LEGEND_PP</span>
<span class="comments">;       </span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       AL_LEGEND, from idlastro, with an extra keyword (background_color),</span>
<span class="comments">;       to specifiy what color will fill the legend box when the keywrod</span>
<span class="comments">;       clear is set.</span>
<span class="comments">;       Create an annotation legend for a plot.</span>
<span class="comments">;       </span>
<span class="comments">;       Because IDL 8.0 contains a LEGEND() function written in IDL, the </span>
<span class="comments">;       original LEGEND procedure in the Astronomy Library is renamed to</span>
<span class="comments">;       AL_LEGEND.     (The original legend.pro remains.)    </span>
<span class="comments">;</span>
<span class="comments">;       This procedure makes a legend for a plot.  The legend can contain</span>
<span class="comments">;       a mixture of symbols, linestyles, Hershey characters (vectorfont),</span>
<span class="comments">;       and filled polygons (usersym).  A test procedure, legendtest.pro,</span>
<span class="comments">;       shows legend's capabilities.  Placement of the legend is controlled</span>
<span class="comments">;       with keywords like /right, /top, and /center or by using a position</span>
<span class="comments">;       keyword for exact placement (position=[x,y]) or via mouse (/position).</span>
<span class="comments">;       </span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       AL_LEGEND [,items][,keyword options]</span>
<span class="comments">;       </span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       The call:</span>
<span class="comments">;               al_legend,['Plus sign','Asterisk','Period'],psym=[1,2,3]</span>
<span class="comments">;         produces:</span>
<span class="comments">;               -----------------</span>
<span class="comments">;               |               |</span>
<span class="comments">;               |  + Plus sign  |</span>
<span class="comments">;               |  * Asterisk   |</span>
<span class="comments">;               |  . Period     |</span>
<span class="comments">;               |               |</span>
<span class="comments">;               -----------------</span>
<span class="comments">;         Each symbol is drawn with a plots command, so they look OK.</span>
<span class="comments">;         Other examples are given in optional output keywords.</span>
<span class="comments">;</span>
<span class="comments">;       lines = indgen(6)                       ; for line styles</span>
<span class="comments">;       items = 'linestyle '+strtrim(lines,2)   ; annotations</span>
<span class="comments">;       legend,items,linestyle=lines            ; vertical legend---upper left</span>
<span class="comments">;       items = ['Plus sign','Asterisk','Period']</span>
<span class="comments">;       sym = [1,2,3]</span>
<span class="comments">;       al_legend,items,psym=sym                   ; ditto except using symbols</span>
<span class="comments">;       al_legend,items,psym=sym,/horizontal       ; horizontal format</span>
<span class="comments">;       al_legend,items,psym=sym,box=0             ; sans border</span>
<span class="comments">;       al_legend,items,psym=sym,delimiter='='     ; embed '=' betw psym & text</span>
<span class="comments">;       al_legend,items,psym=sym,margin=2          ; 2-character margin</span>
<span class="comments">;       al_legend,items,psym=sym,position=[x,y]    ; upper left in data coords</span>
<span class="comments">;       al_legend,items,psym=sym,pos=[x,y],/norm   ; upper left in normal coords</span>
<span class="comments">;       al_legend,items,psym=sym,pos=[x,y],/device ; upper left in device coords</span>
<span class="comments">;       al_legend,items,psym=sym,/position         ; interactive position</span>
<span class="comments">;       al_legend,items,psym=sym,/right            ; at upper right</span>
<span class="comments">;       al_legend,items,psym=sym,/bottom           ; at lower left</span>
<span class="comments">;       al_legenditems,psym=sym,/center           ; approximately near center</span>
<span class="comments">;       al_legend,items,psym=sym,number=2          ; plot two symbols, not one</span>
<span class="comments">;       al_legend,items,/fill,psym=[8,8,8],colors=[10,20,30]; 3 filled squares</span>
<span class="comments">;       </span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       items = text for the items in the legend, a string array.</span>
<span class="comments">;               For example, items = ['diamond','asterisk','square'].</span>
<span class="comments">;               You can omit items if you don't want any text labels.</span>
<span class="comments">;               </span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;       linestyle = array of linestyle numbers  If linestyle[i] &lt; 0, then omit</span>
<span class="comments">;               ith symbol or line to allow a multi-line entry.     If </span>
<span class="comments">;               linestyle = -99 then text will be left-justified.  </span>
<span class="comments">;       psym = array of plot symbol numbers.  If psym[i] is negative, then a</span>
<span class="comments">;               line connects pts for ith item.  If psym[i] = 8, then the</span>
<span class="comments">;               procedure usersym is called with vertices define in the</span>
<span class="comments">;               keyword usersym.   If psym[i] = 88, then use the previously</span>
<span class="comments">;               defined user symbol.    If 11 &lt;= psym[i] &lt;= 46 then David</span>
<span class="comments">;               Fanning's function SYMCAT() will be used for additional symbols.</span>
<span class="comments">;               (http://www.dfanning.com/programs/symcat.pro).   Note that</span>
<span class="comments">;               PSYM=10 (histogram plot mode) is not allowed since it </span>
<span class="comments">;               cannot be used with the PLOTS command.</span>
<span class="comments">;       vectorfont = vector-drawn characters for the sym/line column, e.g.,</span>
<span class="comments">;               ['!9B!3','!9C!3','!9D!3'] produces an open square, a checkmark,</span>
<span class="comments">;               and a partial derivative, which might have accompanying items</span>
<span class="comments">;               ['BOX','CHECK','PARTIAL DERIVATIVE'].</span>
<span class="comments">;               There is no check that !p.font is set properly, e.g., -1 for</span>
<span class="comments">;               X and 0 for PostScript.  This can produce an error, e.g., use</span>
<span class="comments">;               !20 with PostScript and !p.font=0, but allows use of Hershey</span>
<span class="comments">;               *AND* PostScript fonts together.</span>
<span class="comments">;       N. B.: Choose any of linestyle, psym, and/or vectorfont.  If none is</span>
<span class="comments">;               present, only the text is output.  If more than one</span>
<span class="comments">;               is present, all need the same number of elements, and normal</span>
<span class="comments">;               plot behaviour occurs.</span>
<span class="comments">;               By default, if psym is positive, you get one point so there is</span>
<span class="comments">;               no connecting line.  If vectorfont[i] = '',</span>
<span class="comments">;               then plots is called to make a symbol or a line, but if</span>
<span class="comments">;               vectorfont[i] is a non-null string, then xyouts is called.</span>
<span class="comments">;       /help = flag to print header</span>
<span class="comments">;       /horizontal = flag to make the legend horizontal</span>
<span class="comments">;       /vertical = flag to make the legend vertical (D=vertical)</span>
<span class="comments">;       box = flag to include/omit box around the legend (D=include)</span>
<span class="comments">;       outline_color = color of box outline (D = !P.color)</span>
<span class="comments">;       clear = flag to clear the box area before drawing the legend</span>
<span class="comments">;       background_color = color to fill the legend box when clear is set (D=-1)</span>
<span class="comments">;       delimiter = embedded character(s) between symbol and text (D=none)</span>
<span class="comments">;       colors = array of colors for plot symbols/lines (D=!P.color)</span>
<span class="comments">;       font = scalar font graphics keyword (-1,0 or 1) for text</span>
<span class="comments">;       textcolors = array of colors for text (D=!P.color)</span>
<span class="comments">;       margin = margin around text measured in characters and lines</span>
<span class="comments">;       spacing = line spacing (D=bit more than character height)</span>
<span class="comments">;       pspacing = psym spacing (D=3 characters) (when number of symbols is</span>
<span class="comments">;             greater than 1)</span>
<span class="comments">;       charsize = just like !p.charsize for plot labels</span>
<span class="comments">;       charthick = just like !p.charthick for plot labels</span>
<span class="comments">;       thick = array of line thickness numbers (D = !P.thick), if used, then </span>
<span class="comments">;               linestyle must also be specified</span>
<span class="comments">;       position = data coordinates of the /top (D) /left (D) of the legend</span>
<span class="comments">;       normal = use normal coordinates for position, not data</span>
<span class="comments">;       device = use device coordinates for position, not data</span>
<span class="comments">;       number = number of plot symbols to plot or length of line (D=1)</span>
<span class="comments">;       usersym = 2-D array of vertices, cf. usersym in IDL manual. </span>
<span class="comments">;             (/USERSYM =square, default is to use existing USERSYM definition)</span>
<span class="comments">;       /fill = flag to fill the usersym</span>
<span class="comments">;       /left_legend = flag to place legend snug against left side of plot</span>
<span class="comments">;                 window (D)</span>
<span class="comments">;       /right_legend = flag to place legend snug against right side of plot</span>
<span class="comments">;               window.    If /right,pos=[x,y], then x is position of RHS and</span>
<span class="comments">;               text runs right-to-left.</span>
<span class="comments">;       /top_legend = flag to place legend snug against top of plot window (D)</span>
<span class="comments">;       /bottom = flag to place legend snug against bottom of plot window</span>
<span class="comments">;               /top,pos=[x,y] and /bottom,pos=[x,y] produce same positions.</span>
<span class="comments">;</span>
<span class="comments">;       If LINESTYLE, PSYM, VECTORFONT, THICK, COLORS, or TEXTCOLORS are</span>
<span class="comments">;       supplied as scalars, then the scalar value is set for every line or</span>
<span class="comments">;       symbol in the legend.</span>
<span class="comments">;       </span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       legend to current plot device</span>
<span class="comments">;       </span>
<span class="comments">; OPTIONAL OUTPUTS:</span>
<span class="comments">;       corners = 4-element array, like !p.position, of the normalized</span>
<span class="comments">;         coords for the box (even if box=0): [llx,lly,urx,ury].</span>
<span class="comments">;         Useful for multi-column or multi-line legends, for example,</span>
<span class="comments">;         to make a 2-column legend, you might do the following:</span>
<span class="comments">;           c1_items = ['diamond','asterisk','square']</span>
<span class="comments">;           c1_psym = [4,2,6]</span>
<span class="comments">;           c2_items = ['solid','dashed','dotted']</span>
<span class="comments">;           c2_line = [0,2,1]</span>
<span class="comments">;           al_legend,c1_items,psym=c1_psym,corners=c1,box=0</span>
<span class="comments">;           al_legend,c2_items,line=c2_line,corners=c2,box=0,pos=[c1[2],c1[3]]</span>
<span class="comments">;           c = [c1[0]&lt;c2[0],c1[1]&lt;c2[1],c1[2]>c2[2],c1[3]>c2[3]]</span>
<span class="comments">;           plots,[c[0],c[0],c[2],c[2],c[0]],[c[1],c[3],c[3],c[1],c[1]],/norm</span>
<span class="comments">;         Useful also to place the legend.  Here's an automatic way to place</span>
<span class="comments">;         the legend in the lower right corner.  The difficulty is that the</span>
<span class="comments">;         legend's width is unknown until it is plotted.  In this example,</span>
<span class="comments">;         the legend is plotted twice: the first time in the upper left, the</span>
<span class="comments">;         second time in the lower right.</span>
<span class="comments">;           al_legend,['1','22','333','4444'],linestyle=indgen(4),corners=corners</span>
<span class="comments">;                       ; BOGUS LEGEND---FIRST TIME TO REPORT CORNERS</span>
<span class="comments">;           xydims = [corners[2]-corners[0],corners[3]-corners[1]]</span>
<span class="comments">;                       ; SAVE WIDTH AND HEIGHT</span>
<span class="comments">;           chdim=[!d.x_ch_size/float(!d.x_size),!d.y_ch_size/float(!d.y_size)]</span>
<span class="comments">;                       ; DIMENSIONS OF ONE CHARACTER IN NORMALIZED COORDS</span>
<span class="comments">;           pos = [!x.window[1]-chdim[0]-xydims[0] $</span>
<span class="comments">;                       ,!y.window[0]+chdim[1]+xydims[1]]</span>
<span class="comments">;                       ; CALCULATE POSITION FOR LOWER RIGHT</span>
<span class="comments">;           plot,findgen(10)    ; SIMPLE PLOT; YOU DO WHATEVER YOU WANT HERE.</span>
<span class="comments">;           al_legend,['1','22','333','4444'],linestyle=indgen(4),pos=pos</span>
<span class="comments">;                       ; REDO THE LEGEND IN LOWER RIGHT CORNER</span>
<span class="comments">;         You can modify the pos calculation to place the legend where you</span>
<span class="comments">;         want.  For example to place it in the upper right:</span>
<span class="comments">;           pos = [!x.window[1]-chdim[0]-xydims[0],!y.window[1]-xydims[1]]</span>
<span class="comments">;           </span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;       none</span>
<span class="comments">;       </span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       If keyword help is set, call doc_library to print header.</span>
<span class="comments">;       See notes in the code.  Much of the code deals with placement of the</span>
<span class="comments">;       legend.  The main problem with placement is not being</span>
<span class="comments">;       able to sense the length of a string before it is output.  Some crude</span>
<span class="comments">;       approximations are used for centering.</span>
<span class="comments">;       </span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       Here are some things that aren't implemented.</span>
<span class="comments">;       - An orientation keyword would allow lines at angles in the legend.</span>
<span class="comments">;       - An array of usersyms would be nice---simple change.</span>
<span class="comments">;       - An order option to interchange symbols and text might be nice.</span>
<span class="comments">;       - Somebody might like double boxes, e.g., with box = 2.</span>
<span class="comments">;       - Another feature might be a continuous bar with ticks and text.</span>
<span class="comments">;       - There are no guards to avoid writing outside the plot area.</span>
<span class="comments">;       - There is no provision for multi-line text, e.g., '1st line!c2nd line'</span>
<span class="comments">;         Sensing !c would be easy, but !c isn't implemented for PostScript.</span>
<span class="comments">;         A better way might be to simply output the 2nd line as another item</span>
<span class="comments">;         but without any accompanying symbol or linestyle.  A flag to omit</span>
<span class="comments">;         the symbol and linestyle is linestyle[i] = -1.</span>
<span class="comments">;       - There is no ability to make a title line containing any of titles</span>
<span class="comments">;         for the legend, for the symbols, or for the text.</span>
<span class="comments">;         </span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">; </span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       write, 24-25 Aug 92, F K Knight (knight@ll.mit.edu)</span>
<span class="comments">;       allow omission of items or omission of both psym and linestyle, add</span>
<span class="comments">;         corners keyword to facilitate multi-column legends, improve place-</span>
<span class="comments">;         ment of symbols and text, add guards for unequal size, 26 Aug 92, FKK</span>
<span class="comments">;       add linestyle(i)=-1 to suppress a single symbol/line, 27 Aug 92, FKK</span>
<span class="comments">;       add keyword vectorfont to allow characters in the sym/line column,</span>
<span class="comments">;         28 Aug 92, FKK</span>
<span class="comments">;       add /top, /bottom, /left, /right keywords for automatic placement at</span>
<span class="comments">;         the four corners of the plot window.  The /right keyword forces</span>
<span class="comments">;         right-to-left printing of menu. 18 Jun 93, FKK</span>
<span class="comments">;       change default position to data coords and add normal, data, and</span>
<span class="comments">;         device keywords, 17 Jan 94, FKK</span>
<span class="comments">;       add /center keyword for positioning, but it is not precise because</span>
<span class="comments">;         text string lengths cannot be known in advance, 17 Jan 94, FKK</span>
<span class="comments">;       add interactive positioning with /position keyword, 17 Jan 94, FKK</span>
<span class="comments">;       allow a legend with just text, no plotting symbols.  This helps in</span>
<span class="comments">;         simply describing a plot or writing assumptions done, 4 Feb 94, FKK</span>
<span class="comments">;       added thick, symsize, and clear keyword Feb 96, W. Landsman HSTX</span>
<span class="comments">;               David Seed, HR Wallingford, d.seed@hrwallingford.co.uk</span>
<span class="comments">;       allow scalar specification of keywords, Mar 96, W. Landsman HSTX</span>
<span class="comments">;       added charthick keyword, June 96, W. Landsman HSTX</span>
<span class="comments">;       Made keyword names  left,right,top,bottom,center longer,</span>
<span class="comments">;                                 Aug 16, 2000, Kim Tolbert</span>
<span class="comments">;       Added ability to have regular text lines in addition to plot legend </span>
<span class="comments">;       lines in legend.  If linestyle is -99 that item is left-justified.</span>
<span class="comments">;       Previously, only option for no sym/line was linestyle=-1, but then text</span>
<span class="comments">;       was lined up after sym/line column.    10 Oct 2000, Kim Tolbert</span>
<span class="comments">;       Make default value of thick = !P.thick  W. Landsman  Jan. 2001</span>
<span class="comments">;       Don't overwrite existing USERSYM definition  W. Landsman Mar. 2002</span>
<span class="comments">;	      Added outline_color BT 24 MAY 2004</span>
<span class="comments">;       Pass font keyword to xyouts commands.  M. Fitzgerald, Sep. 2005</span>
<span class="comments">;       Default spacing, pspacing should be relative to charsize. M. Perrin, July 2007</span>
<span class="comments">;       Don't modify position keyword  A. Kimball/ W. Landsman Jul 2007</span>
<span class="comments">;       Small update to Jul 2007 for /NORMAL coords.  W. Landsman Aug 2007</span>
<span class="comments">;       Use SYMCAT() plotting symbols for 11&lt;=PSYM&lt;=46   W. Landsman  Nov 2009</span>
<span class="comments">;       Make a sharper box edge T. Robishaw/W.Landsman July 2010</span>
<span class="comments">;       Added background_color keyword. Paulo Penteado (pp.penteado@gmail.com), Sep/2010</span>
<span class="comments">;-</span>
<a id="al_legend_pp:source"></a>pro al_legend_pp, items, BOTTOM_LEGEND=bottom, BOX = box, CENTER_LEGEND=center, $
    CHARTHICK=charthick, CHARSIZE = charsize, CLEAR = clear, COLORS = colorsi, $
    CORNERS = corners, DATA=data, DELIMITER=delimiter, DEVICE=device, $
    FILL=fill, HELP = help, HORIZONTAL=horizontal,LEFT_LEGEND=left, $
    LINESTYLE=linestylei, MARGIN=margin, NORMAL=normal, NUMBER=number, $
    POSITION=position,PSPACING=pspacing, PSYM=psymi, RIGHT_LEGEND=right, $
    SPACING=spacing, SYMSIZE=symsize, TEXTCOLORS=textcolorsi, THICK=thicki, $
    TOP_LEGEND=top, USERSYM=usersym,  VECTORFONT=vectorfonti, VERTICAL=vertical, $
    OUTLINE_COLOR = outline_color, FONT = font,$
    background_color=bgcolor
<span class="comments">;</span>
<span class="comments">;       =====>> HELP</span>
<span class="comments">;</span>
compile_opt idl2
on_error,2
if keyword_set(help) then begin & doc_library,'al_legend' & return & endif
<span class="comments">;</span>
<span class="comments">;       =====>> SET DEFAULTS FOR SYMBOLS, LINESTYLES, AND ITEMS.</span>
<span class="comments">;</span>
 ni = n_elements(items)
 np = n_elements(psymi)
 nl = n_elements(linestylei)
 nth = n_elements(thicki)
 nv = n_elements(vectorfonti)
 nlpv = max([np,nl,nv])
 n = max([ni,np,nl,nv])                                  <span class="comments">; NUMBER OF ENTRIES</span>
strn = strtrim(n,2)                                     <span class="comments">; FOR ERROR MESSAGES</span>
if n eq 0 then message,'No inputs!  For help, type al_legend,/help.'
if ni eq 0 then begin
  items = replicate('',n)                               <span class="comments">; DEFAULT BLANK ARRAY</span>
endif else begin
  if size(items,/TNAME) NE 'STRING' then message, $
      'First parameter must be a string array.  For help, type al_legend,/help.'
  if ni ne n then message,'Must have number of items equal to '+strn
endelse
symline = (np ne 0) or (nl ne 0)                        <span class="comments">; FLAG TO PLOT SYM/LINE</span>
 if (np ne 0) and (np ne n) and (np NE 1) then message, $
        'Must have 0, 1 or '+strn+' elements in PSYM array.'
 if (nl ne 0) and (nl ne n) and (nl NE 1) then message, $
         'Must have 0, 1 or '+strn+' elements in LINESTYLE array.'
 if (nth ne 0) and (nth ne n) and (nth NE 1) then message, $
         'Must have 0, 1 or '+strn+' elements in THICK array.'

 case nl of 
 0: linestyle = intarr(n)              <span class="comments">;Default = solid</span>
 1: linestyle = intarr(n)  + linestylei
 else: linestyle = linestylei
 endcase 
 
 case nth of 
 0: thick = replicate(!p.thick,n)      <span class="comments">;Default = !P.THICK</span>
 1: thick = intarr(n) + thicki
 else: thick = thicki
 endcase 

 case np of             <span class="comments">;Get symbols</span>
 0: psym = intarr(n)    <span class="comments">;Default = solid</span>
 1: psym = intarr(n) + psymi
 else: psym = psymi
 endcase 

 case nv of 
 0: vectorfont = replicate('',n)
 1: vectorfont = replicate(vectorfonti,n)
 else: vectorfont = vectorfonti
 endcase 
<span class="comments">;</span>
<span class="comments">;       =====>> CHOOSE VERTICAL OR HORIZONTAL ORIENTATION.</span>
<span class="comments">;</span>
if n_elements(horizontal) eq 0 then begin               <span class="comments">; D=VERTICAL</span>
  if n_elements(vertical) eq 0 then vertical = 1
endif else begin
  if n_elements(vertical) eq 0 then vertical = not horizontal
endelse
<span class="comments">;</span>
<span class="comments">;       =====>> SET DEFAULTS FOR OTHER OPTIONS.</span>
<span class="comments">;</span>
if n_elements(box) eq 0 then box = 1
if n_elements(clear) eq 0 then clear = 0
bgcolor=n_elements(bgcolor) ne 0 ? bgcolor : -1

if n_elements(margin) eq 0 then margin = 0.5
if n_elements(delimiter) eq 0 then delimiter = ''
if n_elements(charsize) eq 0 then charsize = !p.charsize
if n_elements(charthick) eq 0 then charthick = !p.charthick
if charsize eq 0 then charsize = 1
if (n_elements (symsize) eq 0) then symsize= charsize + intarr(n)
if n_elements(number) eq 0 then number = 1
 case N_elements(colorsi) of 
 0: colors = replicate(!P.color,n)     <span class="comments">;Default is !P.COLOR</span>
 1: colors = replicate(colorsi,n)
 else: colors = colorsi
 endcase 

 case N_elements(textcolorsi) of 
 0: textcolors = replicate(!P.color,n)      <span class="comments">;Default is !P.COLOR</span>
 1: textcolors = replicate(textcolorsi,n)
 else: textcolors = textcolorsi
 endcase 
 fill = keyword_set(fill)
if n_elements(usersym) eq 1 then usersym = 2*[[0,0],[0,1],[1,1],[1,0],[0,0]]-1

if n_elements(outline_color) EQ 0 then outline_color = !P.Color

<span class="comments">;</span>
<span class="comments">;       =====>> INITIALIZE SPACING</span>
<span class="comments">;</span>
if n_elements(spacing) eq 0 then spacing = 1.2*charsize
if n_elements(pspacing) eq 0 then pspacing = 3*charsize
xspacing = !d.x_ch_size/float(!d.x_size) * (spacing > charsize)
yspacing = !d.y_ch_size/float(!d.y_size) * (spacing > charsize)
ltor = 1                                        <span class="comments">; flag for left-to-right</span>
if n_elements(left) eq 1 then ltor = left eq 1
if n_elements(right) eq 1 then ltor = right ne 1
ttob = 1                                        <span class="comments">; flag for top-to-bottom</span>
if n_elements(top) eq 1 then ttob = top eq 1
if n_elements(bottom) eq 1 then ttob = bottom ne 1
xalign = ltor ne 1                              <span class="comments">; x alignment: 1 or 0</span>
yalign = -0.5*ttob + 1                          <span class="comments">; y alignment: 0.5 or 1</span>
xsign = 2*ltor - 1                              <span class="comments">; xspacing direction: 1 or -1</span>
ysign = 2*ttob - 1                              <span class="comments">; yspacing direction: 1 or -1</span>
if not ttob then yspacing = -yspacing
if not ltor then xspacing = -xspacing
<span class="comments">;</span>
<span class="comments">;       =====>> INITIALIZE POSITIONS: FIRST CALCULATE X OFFSET FOR TEXT</span>
<span class="comments">;</span>
xt = 0
if nlpv gt 0 then begin                         <span class="comments">; SKIP IF TEXT ITEMS ONLY.</span>
if vertical then begin                          <span class="comments">; CALC OFFSET FOR TEXT START</span>
  for i = 0,n-1 do begin
    if (psym[i] eq 0) and (vectorfont[i] eq '') then num = (number + 1) > 3 else num = number
    if psym[i] lt 0 then num = number > 2       <span class="comments">; TO SHOW CONNECTING LINE</span>
    if psym[i] eq 0 then expand = 1 else expand = 2
    thisxt = (expand*pspacing*(num-1)*xspacing)
    if ltor then xt = thisxt > xt else xt = thisxt &lt; xt
    endfor
endif   <span class="comments">; NOW xt IS AN X OFFSET TO ALIGN ALL TEXT ENTRIES.</span>
endif
<span class="comments">;</span>
<span class="comments">;       =====>> INITIALIZE POSITIONS: SECOND LOCATE BORDER</span>
<span class="comments">;</span>
if !x.window[0] eq !x.window[1] then begin
  plot,/nodata,xstyle=4,ystyle=4,[0],/noerase
endif
<span class="comments">;       next line takes care of weirdness with small windows</span>
pos = [min(!x.window),min(!y.window),max(!x.window),max(!y.window)]
case n_elements(position) of
 0: begin
  if ltor then px = pos[0] else px = pos[2]
  if ttob then py = pos[3] else py = pos[1]
  if keyword_set(center) then begin
    if not keyword_set(right) and not keyword_set(left) then $
      px = (pos[0] + pos[2])/2. - xt
    if not keyword_set(top) and not keyword_set(bottom) then $
      py = (pos[1] + pos[3])/2. + n*yspacing
    endif
  nposition = [px,py] + [xspacing,-yspacing]
  end
 1: begin       <span class="comments">; interactive</span>
  message,/inform,'Place mouse at upper left corner and click any mouse button.'
  cursor,x,y,/normal
  nposition = [x,y]
  end
 2: begin       <span class="comments">; convert upper left corner to normal coordinates</span>
  if keyword_set(data) then $
    nposition = convert_coord(position,/to_norm) $
  else if keyword_set(device) then $
    nposition = convert_coord(position,/to_norm,/device) $
  else if not keyword_set(normal) then $
    nposition = convert_coord(position,/to_norm) else nposition= position
  end
 else: message,'Position keyword can have 0, 1, or 2 elements only. Try al_legend,/help.'
endcase

yoff = 0.25*yspacing*ysign                      <span class="comments">; VERT. OFFSET FOR SYM/LINE.</span>

x0 = nposition[0] + (margin)*xspacing            <span class="comments">; INITIAL X & Y POSITIONS</span>
y0 = nposition[1] - margin*yspacing + yalign*yspacing    <span class="comments">; WELL, THIS WORKS!</span>
<span class="comments">;</span>
<span class="comments">;       =====>> OUTPUT TEXT FOR LEGEND, ITEM BY ITEM.</span>
<span class="comments">;       =====>> FOR EACH ITEM, PLACE SYM/LINE, THEN DELIMITER,</span>
<span class="comments">;       =====>> THEN TEXT---UPDATING X & Y POSITIONS EACH TIME.</span>
<span class="comments">;       =====>> THERE ARE A NUMBER OF EXCEPTIONS DONE WITH IF STATEMENTS.</span>
<span class="comments">;</span>
for iclr = 0,clear do begin
  y = y0                                                <span class="comments">; STARTING X & Y POSITIONS</span>
  x = x0
  if ltor then xend = 0 else xend = 1           <span class="comments">; SAVED WIDTH FOR DRAWING BOX</span>

 if ttob then ii = [0,n-1,1] else ii = [n-1,0,-1]
 for i = ii[0],ii[1],ii[2] do begin
  if vertical then x = x0 else y = y0           <span class="comments">; RESET EITHER X OR Y</span>
  x = x + xspacing                              <span class="comments">; UPDATE X & Y POSITIONS</span>
  y = y - yspacing
  if nlpv eq 0 then goto,TEXT_ONLY              <span class="comments">; FLAG FOR TEXT ONLY</span>
  if (psym[i] eq 0) and (vectorfont[i] eq '') then num = (number + 1) > 3 else num = number
  if psym[i] lt 0 then num = number > 2         <span class="comments">; TO SHOW CONNECTING LINE</span>
  if psym[i] eq 0 then expand = 1 else expand = 2
  xp = x + expand*pspacing*indgen(num)*xspacing
  if (psym[i] gt 0) and (num eq 1) and vertical then xp = x + xt/2.
  yp = y + intarr(num)
  if vectorfont[i] eq '' then yp = yp + yoff
  if psym[i] eq 0 then begin
    xp = [min(xp),max(xp)]                      <span class="comments">; TO EXPOSE LINESTYLES</span>
    yp = [min(yp),max(yp)]                      <span class="comments">; DITTO</span>
    endif
  if (psym[i] eq 8) and (N_elements(usersym) GT 1) then $
                usersym,usersym,fill=fill,color=colors[i]
<span class="comments">;; extra by djseed .. psym=88 means use the already defined usersymbol</span>
 if psym[i] eq 88 then p_sym =8 else $
 if psym[i] EQ 10 then $
         message,'PSYM=10 (histogram mode) not allowed to al_legend.pro' $
 else  if psym[i] GT 8 then p_sym = symcat(psym[i]) else p_sym= psym[i]

  if vectorfont[i] ne '' then begin
<span class="comments">;    if (num eq 1) and vertical then xp = x + xt/2      ; IF 1, CENTERED.</span>
    xyouts,xp,yp,vectorfont[i],width=width,color=colors[i] $
      ,size=charsize,align=xalign,charthick = charthick,/norm,font=font
    xt = xt > width
    xp = xp + width/2.
  endif else begin
    if symline and (linestyle[i] ge 0) then plots,xp,yp,color=colors[i] $
      ,/normal,linestyle=linestyle[i],psym=p_sym,symsize=symsize[i], $
      thick=thick[i]
  endelse

  if vertical then x = x + xt else if ltor then x = max(xp) else x = min(xp)
  if symline then x = x + xspacing
  TEXT_ONLY:
  if vertical and (vectorfont[i] eq '') and symline and (linestyle[i] eq -99) then x=x0 + xspacing
  xyouts,x,y,delimiter,width=width,/norm,color=textcolors[i], $
         size=charsize,align=xalign,charthick = charthick,font=font
  x = x + width*xsign
  if width ne 0 then x = x + 0.5*xspacing
  xyouts,x,y,items[i],width=width,/norm,color=textcolors[i],size=charsize, $
             align=xalign,charthick=charthick,font=font
  x = x + width*xsign
  if not vertical and (i lt (n-1)) then x = x+2*xspacing<span class="comments">; ADD INTER-ITEM SPACE</span>
  xfinal = (x + xspacing*margin)
  if ltor then xend = xfinal > xend else xend = xfinal &lt; xend   <span class="comments">; UPDATE END X</span>
 endfor

 if (iclr lt clear ) then begin
<span class="comments">;       =====>> CLEAR AREA</span>
        x = nposition[0]
        y = nposition[1]
        if vertical then bottom = n else bottom = 1
        ywidth = - (2*margin+bottom-0.5)*yspacing
        corners = [x,y+ywidth,xend,y]
<span class="comments">;        polyfill,[x,xend,xend,x,x],y + [0,0,ywidth,ywidth,0],/norm,color=-1</span>
        polyfill,[x,xend,xend,x,x],y + [0,0,ywidth,ywidth,0],/norm,color=bgcolor
<span class="comments">;       plots,[x,xend,xend,x,x],y + [0,0,ywidth,ywidth,0],thick=2</span>
 endif else begin

<span class="comments">;</span>
<span class="comments">;       =====>> OUTPUT BORDER</span>
<span class="comments">;</span>
        x = nposition[0]
        y = nposition[1]
        if vertical then bottom = n else bottom = 1
        ywidth = - (2*margin+bottom-0.5)*yspacing
        corners = [x,y+ywidth,xend,y]
        if box then plots,[x,xend,xend,x,x,xend],y + [0,0,ywidth,ywidth,0,0],/norm, $
        	color = outline_color
        return
 endelse
endfor

end

</code>
    </div>
  </body>
</html>