<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue May 16 12:42:24 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pp_drawsphericalpoly.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pp_drawsphericalpoly.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">; :Author: Paulo Penteado (http://www.ppenteado.net), Aug/2015</span>
<span class="comments">;-</span>


<span class="comments">;+</span>
<span class="comments">; :Hidden:</span>
<span class="comments">; </span>
<span class="comments">; :Author: Paulo Penteado (http://www.ppenteado.net), Aug/2015</span>
<span class="comments">;-</span>
<a id="pp_drawsphericalpoly_cg:source"></a>pro pp_drawsphericalpoly_cg,paths,colors,_ref_extra=ex,$
  irgbt
compile_opt idl2,logical_predicate,hidden

if n_elements(irgbt) then begin
  rgbt=pp_colortripletolong(irgbt)
  foreach p,paths,ip do cgpolygon,p[0,*],p[1,*],color=rgbt[colors[ip]],_strict_extra=ex
endif else begin
  foreach p,paths,ip do cgpolygon,p[0,*],p[1,*],color=colors[ip],_strict_extra=ex
endelse

end

<span class="comments">;+</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (http://www.ppenteado.net), Aug/2015</span>
<span class="comments">;-</span>
<a id="pp_drawsphericalpoly_direct:source"></a>pro pp_drawsphericalpoly_direct,paths,colors,_ref_extra=ex,$
  irgbt,stackmap=stackm,original_image=origim,maxstack=maxstack,$
  stacklist=stacklist,stackcount=stackc,verbose=verbose,do_stack=do_stack,$
  weights=weights,stackweights=stackw,doweight=dow,stackindex=stacki,doi=doi,$
  pcount=pcount,e_map=e_map,map_structure=mapstr,image_mapstr=image_mapstr,$
  xsize=xsize,ysize=ysize
  compile_opt idl2,logical_predicate,hidden


if n_elements(mapstr) then begin
  lcolors=list(colors,/extract)
  ip=0
  while ip lt n_elements(paths) do begin
    p=paths[ip]
    xy=map_proj_forward(reform(p[0,*]),reform(p[1,*]),map_structure=mapstr,polygons=polygons)
    if n_elements(xy) lt 6 then begin
      <span class="comments">;print,ip</span>
      paths.remove,ip
      lcolors.remove,ip
      continue
    endif
    if n_elements(polygons) ne n_elements(p[0,*])+1 then begin
      po=pp_connectivity_list(polygons)
      if n_elements(po) ne 1 then begin
        paths.remove,ip
        oc=lcolors[ip]
        lcolors.remove,ip
        ipo=ip
        foreach ppo,po do if n_elements(ppo) ge 3 then begin
          lcolors.add,oc,ip
          paths.add,xy[*,ppo],ip++
        endif
      endif else begin
        paths[ip]=xy
      endelse
    endif else paths[ip]=xy
    ip++
  endwhile
  colors=lcolors.toarray()
endif

if do_stack then begin
  oldmap=!map
  if n_elements(e_map) then begin
     p0lon=0 & p0lat=0 & mrot=0
    _e_map=pp_structextract(e_map,p0lat=p0lat,p0lon=p0lon,rot=mrot)
    olddev=!d.name
    set_plot,'z'
    origim=tvrd()
    <span class="comments">;device,get_decomposed=origdec</span>
    eh={fill:1,color:cgcolor('red')}
    xsize=n_elements(xsize) ? xsize : 640
    ysize=n_elements(ysize) ? ysize : 480
    device,set_resolution=[xsize,ysize]
    map_set,p0lat,p0lon,mrot,/noborder,_strict_extra=_e_map,e_horizon=eh
  endif else begin
    eh={fill:1,color:cgcolor('red')}
    map_set,/noborder,/isotropic,/cylindrical,e_horizon=eh
  endelse
  if dow && (n_elements(weights) ne n_elements(colors)) then weights=replicate(1d0,n_elements(colors))
  
  mapim=tvrd(channel=0)
  maskrgb=tvrd()
  mask=maskrgb eq cgcolor('red')
  nmask=total(mask,/integer) 
  szm=size(mapim,/dimensions)
  stackc=lon64arr(szm)
  if do_stack then pcount=lon64arr(n_elements(colors))
  if do_stack eq 1 then begin
    maxstack=n_elements(maxstack) ? maxstack : n_elements(paths)
    stackm=dblarr([maxstack,szm])+!values.d_nan
    if dow then stackw=stackm
    if doi then stacki=lonarr([maxstack,szm])-1
  endif else begin
    stackm=objarr(szm)
    foreach s,stackm,is do stackm[is]=list()
    if dow then begin
      stackw=objarr(szm)
      foreach s,stackw,is do stackw[is]=list()
    endif
    if doi then begin
      stacki=objarr(szm)
      foreach s,stacki,is do stacki[is]=list()
    endif
  endelse
  print,'n paths: ',n_elements(paths)
  foreach p,paths,ip do begin
    erase
    polyfill,p[0,*],p[1,*],/data,_strict_extra=ex,color=cgcolor('blue')
    if verbose && ~(ip mod verbose) then print,ip
    tmprgb=tvrd()
    tmp=mask and (tmprgb eq cgcolor('blue')) 
    w=where(tmp,wc)
    if wc gt nmask/2 then begin
      <span class="comments">;tmp=mask and (not tmp)</span>
      w=where(tmp,wc)
    endif
    pcount[ip]=wc
    if wc then begin
      cip=colors[ip]
      if dow then wip=weights[ip]
      if do_stack eq 1 then begin
        foreach pt,w do if stackc[pt] lt maxstack then stackm[pt*maxstack+stackc[pt]]=cip
        if dow then foreach pt,w do if stackc[pt] lt maxstack then stackw[pt*maxstack+stackc[pt]]=wip
        if doi then foreach pt,w do if stackc[pt] lt maxstack then stacki[pt*maxstack+stackc[pt]]=ip
      endif
      if do_stack eq 2 then begin
        foreach pt,w do (stackm[pt]).add,cip
        if dow then foreach pt,w do (stackw[pt]).add,wip
        if doi then foreach pt,w do (stacki[pt]).add,ip
      endif
      stackc[w]+=1
    endif
  endforeach
  print,'done with the paths'
  if n_elements(olddev) then begin
    device,set_resolution=size(origim,/dimensions)<span class="comments">;,decomposed=origdec</span>
    tv,origim
    set_plot,olddev
  endif
  image_mapstr=!map
  !map=oldmap
  return
endif
  
if n_elements(irgbt) then begin
  device,get_decomposed=dec
  if dec then begin
    rgbt=pp_colortripletolong(irgbt)
    foreach p,paths,ip do polyfill,p[0,*],p[1,*],color=rgbt[colors[ip]],/data,_strict_extra=ex
  endif else begin
    tvlct,r,g,b,/get
    tvlct,transpose(irgbt)
    foreach p,paths,ip do polyfill,p[0,*],p[1,*],color=colors[ip],/data,_strict_extra=ex
    tvlct,r,g,b
  endelse
endif else begin
  foreach p,paths,ip do polyfill,p[0,*],p[1,*],color=colors[ip],/data,_strict_extra=ex
endelse
end

<span class="comments">;+</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (http://www.ppenteado.net), Aug/2015</span>
<span class="comments">;-</span>
<a id="pp_drawsphericalpoly_itool:source"></a>pro pp_drawsphericalpoly_itool,paths,colors,_ref_extra=ex,$
  irgbt,polygon=poly,connectivity=conn,x=x,y=y,graphic=graphic
compile_opt idl2,logical_predicate,hidden

if (!version.release ge '8.2.3') then xy=paths.toarray(dimension=2) else begin
  nxy=0LL & foreach p,paths do nxy+=(size(p,/dimensions))[1]
  xy=dblarr(2,nxy)
  count=0LL
  foreach p,paths do begin
    xy[count]=p[*]
    count+=n_elements(p)
  endforeach
endelse
conn=lonarr(n_elements(paths)+n_elements(xy)/2LL)
count=0LL
cols=lonarr(3,n_elements(xy)/2LL)
countc=0LL
foreach p,paths,ip do begin
  np=n_elements(p)/2LL
  conn[count]=np
  conn[count+1]=l64indgen(np)+countc
  count+=np+1
  cols[0,countc]=n_elements(irgbt) ? irgbt[*,colors[ip]]#replicate(1d0,np) : colors[*,ip]#replicate(1d0,np)
  countc+=np
endforeach
x=reform(xy[0,*])
y=reform(xy[1,*])

if keyword_set(graphic) then begin
  <span class="comments">;poly=polygon(x,y,connectivity=conn,vert_colors=cols,_strict_extra=ex,/data)</span>
  <span class="comments">;The following lines were adapted from IDL's polygon.pro, because polygons do not have the property</span>
  <span class="comments">;map_interpolate registered, so the idlitvispolygon has to be created in here.</span>
  <span class="comments">;Without map_interpolate, ipolygon.pro's line 137 will cause points accross sides of the map to be connected</span>
  add2vis=1
  iPolygon, transpose([[x],[y]]), $
    DATA=1,$<span class="comments">;data, DEVICE=device, NORMAL=normal, RELATIVE=relative, TARGET=target, $</span>
    OBJECT=oPolygon, VISUALIZATION=add2vis, SHADING=1, $
    <span class="comments">;COLOR=color, LINESTYLE=linestyle, THICK=thick, _EXTRA=ex</span>
    map_interpolate=0,connectivity=conn,vert_colors=cols,_strict_extra=ex
    Graphic__define
    oGraphic = OBJ_NEW('Polygon', oPolygon)
    <span class="comments">;Done with the code from polygon.pro</span>
    poly=oGraphic
endif else begin
  ipolygon,transpose([[x],[y]]),connectivity=conn,vert_colors=cols,_strict_extra=ex,$
    /data,/visualization,object=poly,map_interpolate=0
endelse

end


<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Draws polygons on a map, with the polygon sides resampled to a large number</span>
<span class="comments">;    of vertices, so that the result resembles a spherical polygon (a polygon where</span>
<span class="comments">;    the sides are great circle arcs). Polygons can be drawn on Coyote Graphics,</span>
<span class="comments">;    iTools, Function Graphics or Direct Graphics. Se examples below.</span>
<span class="comments">;    Makes use of `pp_sphericalpath` to calculate the polygonal approximation to</span>
<span class="comments">;    the spherical polygon.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    ilons: in, required</span>
<span class="comments">;      An array of longitudes for the vertices which are to be connected by a path made of great circles.</span>
<span class="comments">;      Must be in degrees. Multiple polygons are supported in two different ways: 1) If all N polygons have </span>
<span class="comments">;      the same number of vertices (M), lons can be given as a [M,N] array. 2) For arbitrary numbers of vertices,</span>
<span class="comments">;      lons is given as a list, where each list element is an array of vertices for one polygon.</span>
<span class="comments">;    ilats: in, required</span>
<span class="comments">;      An array of latitudes for the vertices which are to be connected by a path made of great circles.</span>
<span class="comments">;      Must be in degrees. Multiple polygons are supported in two different ways: 1) If all N polygons have </span>
<span class="comments">;      the same number of vertices (M), lats can be given as a [M,N] array. 2) For arbitrary numbers of vertices,</span>
<span class="comments">;      lons is given as a list, where each list element is an array of vertices for one polygon.</span>
<span class="comments">;    icolors: in, required</span>
<span class="comments">;      An array with the color to be used to draw/fill the polygons. If `rgb_table`</span>
<span class="comments">;      is not given, this array is assumed to contain the colors in the system used</span>
<span class="comments">;      by the kind of plotting selected: either a [3,M] array of color triplets, one triple</span>
<span class="comments">;      per each of the M polygons, or a long integer array, with one long-integer-coded</span>
<span class="comments">;      color for each of the M polygons.</span>
<span class="comments">;      If `rgb_table` is given, then colors can be an array of any numerical type, and</span>
<span class="comments">;      the polygon colors will be determined by mapping the values in `colors` to</span>
<span class="comments">;      values in the 256-value colortable specified by `rgb_table`.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    _ref_extra: in, out, optional</span>
<span class="comments">;      Any extra arguments are passed to the polygon plotting routine: cgpolygon if</span>
<span class="comments">;      `cg` is selected, ipolygon if `itool` is selected, polygon() if `graphics` is</span>
<span class="comments">;      selected, or polyfill, if `direct` is selected.</span>
<span class="comments">;    rgb_table: in, optional</span>
<span class="comments">;      The color table to be used to map intensities into colors. This can be either</span>
<span class="comments">;      a scalar, which will be used to select one of IDL's predefined colortables</span>
<span class="comments">;      (0 is grayscale), or a [3,256] array of color triples, or a 256-element array</span>
<span class="comments">;      of long integers.</span>
<span class="comments">;    cg: in, optional, default=0</span>
<span class="comments">;      If set, plotting is made with Coyote Graphics' cgpolygon.</span>
<span class="comments">;    graphics: in, optional, default=1</span>
<span class="comments">;      If set, plotting is made with IDL's Function Graphics' polygon().</span>
<span class="comments">;    itool: in, optional, default=0</span>
<span class="comments">;      If set, plotting is made with IDL's iTools' ipolygon.</span>
<span class="comments">;    direct: in, optional, default=0</span>
<span class="comments">;      If set, plotting is made with IDL's Direct Graphics' polyfill.</span>
<span class="comments">;    maxlength: in, optional</span>
<span class="comments">;      Passed on to `pp_sphericalpath`, determines the maximum length of the polygon</span>
<span class="comments">;      sides used for plotting, in degrees.</span>
<span class="comments">;    nsegments: in, optional</span>
<span class="comments">;      Passed on to `pp_sphericalpath`, determines the number of segments to use for</span>
<span class="comments">;      the polygon sides.</span>
<span class="comments">;    polygon: out, optional</span>
<span class="comments">;      If Function Graphics or iTools are being used for plotting, returns the polygon</span>
<span class="comments">;      object created with them.</span>
<span class="comments">;    x: out, optional</span>
<span class="comments">;      If Function Graphics or iTools are being used for plotting, arrays of x and y points</span>
<span class="comments">;      get created, one for each vertex of all polygons plotted. This keyword returns</span>
<span class="comments">;      the x coordinates of the vertices created.</span>
<span class="comments">;    y: out, optional</span>
<span class="comments">;      If Function Graphics or iTools are being used for plotting, arrays of x and y points</span>
<span class="comments">;      get created, one for each vertex of all polygons plotted. This keyword returns</span>
<span class="comments">;      the y coordinates of the vertices created.</span>
<span class="comments">;    connectivity: out, optional</span>
<span class="comments">;      If Function Graphics or iTools are being used for plotting, arrays of x and y points</span>
<span class="comments">;      get created, one for each vertex of all polygons plotted. This keyword returns</span>
<span class="comments">;      the connectivity array which specifies which vertices belong to each polygon. See IDL's help</span>
<span class="comments">;      on polygon() for more details.</span>
<span class="comments">;    fill: in, optional, default=0.</span>
<span class="comments">;      If Coyote Graphics' cgpolygon is being used, this keyword determines if</span>
<span class="comments">;      the polygons are drawn just as outlines, or should be filled (outlines and</span>
<span class="comments">;      fills share the same colors).</span>
<span class="comments">;    do_stack: in, optional, default=0</span>
<span class="comments">;      If set to 1, instead of drawing the polygons on the graphics device, a z-buffer will be used</span>
<span class="comments">;      to draw polygons in an invisible direct graphics window, which are used to generate a map of</span>
<span class="comments">;      where each polygon falls (`stackmap`). This will probably be more clearly explained by the</span>
<span class="comments">;      examples below. Note that setting do_stack to a value higher than 1 is not the same as setting</span>
<span class="comments">;      it to 1: other values turn on alternative stack algorithms, which at this time are still</span>
<span class="comments">;      experimental and thus not yet documented.</span>
<span class="comments">;    stackmap: out, optional</span>
<span class="comments">;      if `do_stack` is turned on, this argument returns the stacked map generated. If the algorithm</span>
<span class="comments">;      selected is `do_stack`=1, this will be an array of dimensions [`maxstack`,`xsize`,`ysize`], where</span>
<span class="comments">;      [`xsize`,`ysize`] are the dimensions of the map created, and `maxstack` specifies the maximum number</span>
<span class="comments">;      layers the map stack can have. At a given location [x,y] in the map, the values stackmap[*,x,y]</span>
<span class="comments">;      are all the values present in `icolors` that fell onto that location on the map. The argument</span>
<span class="comments">;      `stackcount` is often useful, as it records how many layers were stacked at each location in the</span>
<span class="comments">;      map. This will probably be more clearly explained by the examples below.</span>
<span class="comments">;    stackcount: out, optional</span>
<span class="comments">;      if `do_stack` is turned on, this argument returns the count of stacked layers in the `stackmap`</span>
<span class="comments">;      generated. At a given location [x,y] in the map, stackcount[x,y] is the number of polygons that</span>
<span class="comments">;      fell on that map location (the number of layers in `stackmap` at that location). This will probably</span>
<span class="comments">;      be more clearly explained by the examples below.</span>
<span class="comments">;    maxstack: in, optional</span>
<span class="comments">;      Specifies the first dimension of the `stackmap` array, which is the maximum number of layers being</span>
<span class="comments">;      tracked falling on each location on the map. If not set, it defaults to the number of polygons provided</span>
<span class="comments">;      in `ilons`, `ilats`, `icolors`. If there are many polygons, it is probably wise to specify a smaller</span>
<span class="comments">;      value for maxstack, to avoid using too much memory. Use `stackcount` to check that at no location in the</span>
<span class="comments">;      map there were polygons missed because that location had more overlapping layers than could fit into</span>
<span class="comments">;      `stackmap`: if `stackcount` is everywhere smaller than or equal to `maxstack`, no polygons were lost in</span>
<span class="comments">;      `stackmap`.</span>
<span class="comments">;    stackindex: out, optional</span>
<span class="comments">;      If `do_stack` is turned on, this argument returns the an array similar to `stackmap`, but its values</span>
<span class="comments">;      are the indices to of the polygons that fall on each location, instead of being the intensities (`icolors`).</span>
<span class="comments">;    xsize: in, optional, default=640</span>
<span class="comments">;      If `do_stack` is set to 1, this specifies the width of the map to generate (see `stackmap`).  </span>
<span class="comments">;    ysize: in, optional, default=480</span>
<span class="comments">;      If `do_stack` is set to 1, this specifies the height of the map to generate (see `stackmap`).</span>
<span class="comments">;    e_map: in, optional</span>
<span class="comments">;      If `do_stack` is set to 1, set this argument to a structure containing any parameters to be passed</span>
<span class="comments">;      to map_set, which is used to define the map projection used to make `stackmap`. This will probably</span>
<span class="comments">;      be more clearly explained by the examples below.</span>
<span class="comments">;    image_mapstr: out, optional</span>
<span class="comments">;      If `do_stack` is set to 1, this argument will return the map structure created by map_set, which is</span>
<span class="comments">;      used to define the map projection used to make `stackmap`.</span>
<span class="comments">;    pcount: out, optional</span>
<span class="comments">;      If `do_stack` is turned on, this argument returns the an array with the number of map pixels covered</span>
<span class="comments">;      by each polygon.</span>
<span class="comments">;    weights: in, optional</span>
<span class="comments">;    stackweights: out, optional</span>
<span class="comments">;    verbose: in, optional</span>
<span class="comments">;    </span>
<span class="comments">;      </span>
<span class="comments">;      </span>
<span class="comments">;    :Examples:</span>
<span class="comments">;    </span>
<span class="comments">;      First, let's create some data to plot::</span>
<span class="comments">;      </span>
<span class="comments">;        ;create several rectangles</span>
<span class="comments">;        lons=dblarr(4,10)</span>
<span class="comments">;        for i=0,9 do lons[*,i]=[-85d0,-65d0,-55d0,-75d0]+i*25d0</span>
<span class="comments">;        lats=dblarr(4,10)</span>
<span class="comments">;        for i=0,9 do lats[*,i]=[-65d0,55d0,45d0,-75d0]</span>
<span class="comments">;        ;set their colors</span>
<span class="comments">;        colors=dindgen(10)</span>
<span class="comments">;      Now, plot the rectangles on a Graphics map::</span>
<span class="comments">;      </span>
<span class="comments">;        m=map('mollweide')</span>
<span class="comments">;        pp_drawsphericalpoly,lons,lats,colors,rgb_table=13,linestyle='none'</span>
<span class="comments">;      .. image:: pp_drawsphericalpoly_ex1.png</span>
<span class="comments">;      </span>
<span class="comments">;      Plot the rectangles on an imap::</span>
<span class="comments">;      </span>
<span class="comments">;        imap,map_projection='sinusoidal'</span>
<span class="comments">;        pp_drawsphericalpoly,lons,lats,colors,rgb_table=13,linestyle='none',/itool</span>
<span class="comments">;      .. image:: pp_drawsphericalpoly_ex2.png</span>
<span class="comments">;      </span>
<span class="comments">;      Plot the rectangles on a Coyote Graphics map::</span>
<span class="comments">;      </span>
<span class="comments">;        m=cgmap('robinson',/erase,/isotropic,/window)</span>
<span class="comments">;        cgmap_grid,map=m,/box,/addcmd</span>
<span class="comments">;        cgloadct,13</span>
<span class="comments">;        pp_drawsphericalpoly,lons,lats,bytscl(colors),/cg,/fill,map=m,/addcmd</span>
<span class="comments">;      .. image:: pp_drawsphericalpoly_ex3.png</span>
<span class="comments">;      </span>
<span class="comments">;      Plot the rectangles on a Direct Graphics map::</span>
<span class="comments">;      </span>
<span class="comments">;        map_set,0d0,0d0,/cylindrical,/isotropic,/grid,/label</span>
<span class="comments">;        pp_drawsphericalpoly,lons,lats,colors,rgb_table=13,/direct</span>
<span class="comments">;      .. image:: pp_drawsphericalpoly_ex4.png</span>
<span class="comments">;</span>
<span class="comments">;      Now, let's make some data that spans the tricky region around the pole::</span>
<span class="comments">;</span>
<span class="comments">;        ;make up the coordinates for the coordinates of 3 rectangular fields of view near the north pole:</span>
<span class="comments">;        lons=[[20d0,240d0,260d0,0d0],[80d0,180d0,200d0,60d0],[50d0,210d0,230d0,30d0]]</span>
<span class="comments">;        lats=[[62d0,60d0,60d0,62d0],[62d0,60d0,60d0,62d0],[65d0,67d0,67d0,65d0]]</span>
<span class="comments">;        ;make up some pixel values to determine the color used to fill the 3 rectangles</span>
<span class="comments">;        pixvals=dindgen(3)</span>
<span class="comments">;</span>
<span class="comments">;      Create an imap to plot these polygons::</span>
<span class="comments">;</span>
<span class="comments">;        imap,map_proj='orthographic',center_lat=60d0</span>
<span class="comments">;</span>
<span class="comments">;      Draw the polygons::</span>
<span class="comments">;</span>
<span class="comments">;        pp_drawsphericalpoly,lons,lats,pixvals,rgb_table=13,/itool</span>
<span class="comments">;      .. image:: pp_drawsphericalpoly_ex5.png</span>
<span class="comments">;      </span>
<span class="comments">;      Now, an example with overlapping polygons, making an overlap map and taking the</span>
<span class="comments">;      mean of the values on overlap::</span>
<span class="comments">;        </span>
<span class="comments">;        lats=[[62d0,60d0,60d0,62d0],[62d0,60d0,60d0,62d0],[70d0,72d0,72d0,70d0],[80d0,87d0,87d0,80d0]]</span>
<span class="comments">;        lons=[[40d0,220d0,250d0,0d0],[80d0,180d0,200d0,60d0],[50d0,200d0,240d0,20d0],[70d0,70d0,95d0,95d0]]</span>
<span class="comments">;        pixvals=[0d0,-1d0,-3d0,2d0]</span>
<span class="comments">;        </span>
<span class="comments">;      First, take a look at the overlayed polygons::</span>
<span class="comments">;        </span>
<span class="comments">;        m=map('orthographic',center_lat=30d0)</span>
<span class="comments">;      .. image:: pp_drawsphericalpoly_ex6.png</span>
<span class="comments">;        </span>
<span class="comments">;      Now, make the stack map::</span>
<span class="comments">;      </span>
<span class="comments">;        pp_drawsphericalpoly,lons,lats,pixvals,rgb_table=13</span>
<span class="comments">;        limit=[-90,-180,90,180]</span>
<span class="comments">;        e_map={cylindrical:1,noborder:1,xmargin:0,ymargin:0,limit:limit,isotropic:1}</span>
<span class="comments">;        pp_drawsphericalpoly,lons,lats,pixvals,do_stack=1,stackc=stackc,e_map=e_map,xsize=3000,ysize=1500,maxstack=4,stackm=stackm</span>
<span class="comments">;        </span>
<span class="comments">;      Look at the coverage map - an array where each value is the number of polygons that fell onto that place on the map::</span>
<span class="comments">;      </span>
<span class="comments">;        im0=image(stackc,map_projection='equirectangular',grid_units=2,image_location=limit[[1,0]],image_dimensions=[limit[3]-limit[1],limit[2]-limit[0]],dimensions=[900,500],color='cyan',aspect_ratio=5.,limit=[30,-180,90,180])</span>
<span class="comments">;        im1=image(stackc,map_projection='orthographic',center_lat=30,grid_units=2,image_location=limit[[1,0]],image_dimensions=[limit[3]-limit[1],limit[2]-limit[0]],,dimensions=[900,500],color='cyan',rgb_table=13)</span>
<span class="comments">;      .. image:: pp_drawsphericalpoly_ex7.png</span>
<span class="comments">;      .. image:: pp_drawsphericalpoly_ex8.png</span>
<span class="comments">;        </span>
<span class="comments">;      Make an average image from stackm, by taking then mean over the stack (first) dimension::</span>
<span class="comments">;      </span>
<span class="comments">;        stackmean=mean(stackm,dimension=1,/nan)</span>
<span class="comments">;        im2=image(stackmean,map_projection='orthographic',center_lat=90,grid_units=2,image_location=limit[[1,0]],image_dimensions=[limit[3]-limit[1],limit[2]-limit[0]],dimensions=[900,500],color='cyan',rgb_table=13)</span>
<span class="comments">;      .. image:: pp_drawsphericalpoly_ex9.png</span>
<span class="comments">;        </span>
<span class="comments">;        </span>
<span class="comments">;</span>
<span class="comments">;      </span>
<span class="comments">; :Requires:</span>
<span class="comments">;   If Coyote Graphics are to be used, the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php#COYOTE_LIBRARY_DOWNLOAD>` </span>
<span class="comments">;   needs to be installed.</span>
<span class="comments">;   </span>
<span class="comments">;   Also needed are `pp_sphericalpath`, `pp_longtocolortriple`, `pp_colortripletolong`, </span>
<span class="comments">;   and `tessellateshapes_pp`, from `pp_lib &lt;http://www.ppenteado.net/idl/pp_lib.html>`).</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (http://www.ppenteado.net), Aug/2015</span>
<span class="comments">;-</span>
<a id="pp_drawsphericalpoly:source"></a>pro pp_drawsphericalpoly,ilons,ilats,icolors,_ref_extra=ex,$
  rgb_table=rgbt,$
  cg=cg,graphics=graphics,itool=itool,direct=direct,$
  maxlength=maxlength,nsegments=nsegments,polygon=polygon,$
  x=x,y=y,connectivity=conn,fill=fill,$
  stackmap=stackm,original_image=origim,maxstack=maxstack,$
  stacklist=stacklist,stackcount=stackc,verbose=verbose,do_stack=do_stack,$
  weights=weights,stackweights=stackw,stackindex=stacki,pcount=pcount,no_fix_lon=no_fix_lon,$
  map_structure=mapstr,image_mapstr=image_mapstr,xsize=xsize,ysize=ysize,e_map=e_map,$
  bmin=bmin,bmax=bmax,bnan=bnan,btop=btop
compile_opt idl2,logical_predicate



if (size(ilons,/n_dimensions) eq 1) and ~isa(ilons,'list') then begin
  lons=[[ilons],[ilons]]
  lats=[[ilats],[ilats]]
endif else begin
  lons=ilons
  lats=ilats
endelse

nic=n_elements(icolors)
if size(lons,/n_dimensions) eq 2 then begin
  np=(size(lons,/dimensions))[1]
endif else np=n_elements(lons)

if nic eq 0 then begin
  colors=dindgen(np)
  rgbt=0
endif else begin
  colors=icolors
endelse

verbose=n_elements(verbose) ? verbose : 0
do_stack=n_elements(do_stack) ? do_stack : 0
no_fix_lon=keyword_set(no_fix_lon)

<span class="comments">;Force the _tessellateshapes method in tessellateshapes_pp to be compiled after</span>
<span class="comments">;IDL's native method. </span>
r=routine_info()
if total(strmatch(r,'IDLITVISPOLYGON__DEFINE')) eq 0 then begin
  resolve_routine,'IDLITVISPOLYGON__DEFINE',/compile_full_file
endif
resolve_routine,'TESSELLATESHAPES_PP',/compile_full_file

<span class="comments">;Default parameters</span>
cg=keyword_set(cg)
itool=keyword_set(itool)
graphics=keyword_set(graphics)
direct=keyword_set(direct)
if do_stack then begin
  direct=1
  itool=0
  graphics=0
  cg=0
  dow=arg_present(stackw)
  doi=arg_present(stacki)
endif else begin
  dow=0
  doi=0
endelse

<span class="comments">;Get the spherical polygons</span>
paths=pp_sphericalpath(lons,lats,maxlength=maxlength,nsegments=nsegments,no_fix_lon=no_fix_lon)<span class="comments">;,/open)</span>
if ~no_fix_lon then foreach p,paths,ip do begin
  p[0,*]=(p[0,*]+360d0) mod 360
  w=where(p[0,*] gt 180d0,wc)
  if wc then begin
    p[0,w]-=360d0
    paths[ip]=p
  endif
<span class="comments">;  if n_elements(maxlength) then begin </span>
<span class="comments">;</span>
<span class="comments">;    pdiffs=p[*,1:-1]-p[*,0:-2]</span>
<span class="comments">;    pdiffs=sqrt(total(pdiffs^2,1))</span>
<span class="comments">;    w=where(pdiffs gt maxlength*10d0,wc)</span>
<span class="comments">;;  if wc then begin</span>
<span class="comments">;;    print,'found ',wc,' points to split polygon'</span>
<span class="comments">;;    p0=p[*,0:w[0]]</span>
<span class="comments">;;    p1=p[*,w[0]+1:-1]</span>
<span class="comments">;;    paths[ip]=p0</span>
<span class="comments">;;    paths.add,p1,ip+1</span>
<span class="comments">;;    sz=size(colors,/n_dim)</span>
<span class="comments">;;    colors=sz eq 1 ? [colors[0:ip],colors[ip:-1]] : [[colors[*,0:ip]],[colors[*,ip:-1]]]  </span>
<span class="comments">;;  endif</span>
<span class="comments">;  ;s=sort(pdiffs)</span>
<span class="comments">;  ;pds=pdiffs[s]</span>
<span class="comments">;  ;w=where((pds[1:-1] gt 10d0*pds[0:-2]) and (pds[0:-2] gt 0d0),wc)</span>
<span class="comments">;  endif</span>
endforeach

<span class="comments">;Map the colors, if a map is set</span>
if n_elements(rgbt) then begin
  if n_elements(rgbt) eq 1 then begin
    loadct,rgbt
    tvlct,irgbt,/get
    irgbt=transpose(irgbt)
  endif else begin
    sz=size(rgbt,/dimensions)
    if n_elements(sz) eq 2 then irgbt=rgbt else begin
      irgbt=pp_longtocolortriple(rgbt)
    endelse
  endelse
  <span class="comments">;Map the input colors into the [0,255] range</span>
  iicolors=isa(colors,'byte') ? colors : bytscl(colors,min=bmin,max=bmax,nan=bnan,top=btop)
endif else begin
  iicolors=colors  
endelse

<span class="comments">;Call the drawing function</span>
case 1 of
  (cg): pp_drawsphericalpoly_cg,paths,iicolors,_strict_extra=ex,irgbt,fill=fill
  (itool): pp_drawsphericalpoly_itool,paths,iicolors,_strict_extra=ex,irgbt<span class="comments">;,fill=fill</span>
  (direct): pp_drawsphericalpoly_direct,paths,iicolors,_strict_extra=ex,irgbt,$
    stackmap=stackm,original_image=origim,maxstack=maxstack,$
    stacklist=stacklist,stackcount=stackc,verbose=verbose,do_stack=do_stack,weights=weights,$
    stackweights=stackw,doweight=dow,stackindex=stacki,doi=doi,pcount=pcount,map_structure=mapstr,$
    image_mapstr=image_mapstr,xsize=xsize,ysize=ysize,e_map=e_map
  else: pp_drawsphericalpoly_itool,paths,iicolors,_strict_extra=ex,irgbt,polygon=polygon,$
    x=x,y=y,connectivity=conn,/graphic
endcase

end
</code>
    </div>
  </body>
</html>