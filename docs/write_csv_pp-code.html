<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue May 16 12:42:28 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>write_csv_pp.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="write_csv_pp.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
  
  <span class="comments">;+</span>
  <span class="comments">; :Author: Paulo Penteado (`http://www.ppenteado.net &lt;http://www.ppenteado.net>`), Feb/2013</span>
  <span class="comments">; This file contains write_csv_pp, and a copy of IDL's write_csv routines (renamed write_csv_pp_original</span>
  <span class="comments">; and write_csv_convert_pp_original), since write_csv_pp requires an edit on the original write_csv.</span>
  <span class="comments">;-</span>



<span class="comments">; $Id: //depot/Release/ENVI51_IDL83/idl/idldir/lib/write_csv.pro#1 $</span>
<span class="comments">;</span>
<span class="comments">; Copyright (c) 2008-2013, Exelis Visual Information Solutions, Inc. All</span>
<span class="comments">;       rights reserved. Unauthorized reproduction is prohibited.</span>

<span class="comments">;----------------------------------------------------------------------------</span>
<a id="write_csv_convert_pp_original:source"></a>function write_csv_convert_pp_original, data,noquote=noquote

  compile_opt idl2, hidden

  switch (SIZE(data, /TYPE)) of

    7: begin   <span class="comments">; string type</span>
      <span class="comments">; Always surround all strings with quotes, to avoid problems with</span>
      <span class="comments">; commas and whitespace.</span>
      if noquote then begin
        data1=data
        nq=where((strpos(data,'"') ge 0) or (strpos(data,',') ge 0),nnq)
        if (nnq gt 0) then begin
          data1[nq]='"'+data[nq]+'"'
        endif
      endif else begin
        data1 = '"'+data+'"'
      endelse
      <span class="comments">; Now look for double-quote chars, which need to be escaped.</span>
      hasQuote = WHERE(STRPOS(data, '"') ge 0, nQuote)
      if (nQuote gt 0) then begin
        d = data[hasQuote]
        for i=0,nQuote-1 do d[i] = STRJOIN(STRTOK(d[i],'"',/EXTRACT,/PRESERVE_NULL),'""')
        data1[hasQuote] = '"' + d + '"'
      endif
      return, data1
    end

    <span class="comments">; Be sure to convert bytes to numbers</span>
    1: return, STRTRIM(FIX(data), 1)

    <span class="comments">; Use a format code for double-precision numbers.</span>
    5: return, STRTRIM(STRING(data, FORMAT='(g)'), 1)

    6: <span class="comments">; complex and dcomplex (fall thru)</span>
    9: return, '"' + STRCOMPRESS(data, /REMOVE_ALL) + '"'

    else: begin
      <span class="comments">; regular numeric types</span>
      return, STRTRIM(data, 2)
    end

  endswitch

end

<span class="comments">;----------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    The WRITE_CSV procedure writes data to a "comma-separated value"</span>
<span class="comments">;    (comma-delimited) text file.</span>
<span class="comments">;</span>
<span class="comments">;    This routine writes CSV files consisting of an optional line of column</span>
<span class="comments">;    headers, followed by columnar data, with commas separating each field.</span>
<span class="comments">;    Each row is a new record.</span>
<span class="comments">;</span>
<span class="comments">;    This routine is written in the IDL language. Its source code can be</span>
<span class="comments">;    found in the file write_csv.pro in the lib subdirectory of the IDL</span>
<span class="comments">;    distribution.</span>
<span class="comments">;</span>
<span class="comments">; :Syntax:</span>
<span class="comments">;    WRITE_CSV, Filename, Data1 [, Data2,..., Data8]</span>
<span class="comments">;      [, HEADER=value]</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    Filename</span>
<span class="comments">;      A string containing the name of the CSV file to write.</span>
<span class="comments">;</span>
<span class="comments">;    Data1...Data8</span>
<span class="comments">;      The data values to be written out to the CSV file. The data arguments</span>
<span class="comments">;      can have the following forms:</span>
<span class="comments">;      * Data1 can be an IDL structure, where each field contains a</span>
<span class="comments">;        one-dimensional array (a vector) of data that corresponds</span>
<span class="comments">;        to a separate column. The vectors must all have the same</span>
<span class="comments">;        number of elements, but can have different data types. If Data1</span>
<span class="comments">;        is an IDL structure, then all other data arguments are ignored.</span>
<span class="comments">;      * Data1 can be a two-dimensional array, where each column in the array</span>
<span class="comments">;        corresponds to a separate column in the output file. If Data1 is</span>
<span class="comments">;        a two-dimensional array, then all other data arguments are ignored.</span>
<span class="comments">;      * Data1...Data8 are one-dimensional arrays (vectors), where each vector</span>
<span class="comments">;        corresponds to a separate column in the output file. Each vector</span>
<span class="comments">;        can have a different data type.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    HEADER</span>
<span class="comments">;      Set this keyword equal to a string array containing the column header</span>
<span class="comments">;      names. The number of elements in HEADER must match the number of</span>
<span class="comments">;      columns provided in Data1...Data8. If HEADER is not present,</span>
<span class="comments">;      then no header row is written.</span>
<span class="comments">;</span>
<span class="comments">;      TABLE_HEADER</span>
<span class="comments">;      Set this keyword to a scalar string or string array containing extra table lines</span>
<span class="comments">;      to be written at the beginning of the file.</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Written, CT, VIS, Nov 2008</span>
<span class="comments">;   MP, VIS, Oct 2009:  Added keyword SKIP_HEADER</span>
<span class="comments">;   Dec 2010:  Better handling for byte and double precision data.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="write_csv_pp_original:source"></a>pro write_csv_pp_original, Filename, Data1, Data2, Data3, Data4, Data5, Data6, Data7, Data8, $
  HEADER=header, TABLE_HEADER=tableHeader,append=append,noquote=noquote

  compile_opt idl2

  ON_ERROR, 2         <span class="comments">;Return on error</span>

  ON_IOERROR, ioerr

  if (N_PARAMS() lt 2) then $
    MESSAGE, 'Incorrect number of arguments.'

  isStruct = SIZE(Data1, /TYPE) eq 8
  isArray = SIZE(Data1, /N_DIM) eq 2

  if (SIZE(Filename,/TYPE) ne 7) then $
    MESSAGE, 'Filename must be a string.'

  if (N_ELEMENTS(Data1) eq 0) then $
    MESSAGE, 'Data1 must contain data.'

  <span class="comments">; Verify that all columns have the same number of elements.</span>

  msg = 'Data fields must all have the same number of elements.'

  if (isStruct) then begin

    nfields = N_TAGS(Data1)
    nrows = N_ELEMENTS(Data1.(0))
    for i=1,nfields-1 do begin
      if (N_ELEMENTS(Data1.(i)) ne nrows) then $
        MESSAGE, msg
    endfor

  endif else if (isArray) then begin

    d = SIZE(Data1, /DIM)
    nfields = d[0]
    nrows = d[1]

  endif else begin  <span class="comments">; Individual data arguments</span>

    nfields = N_PARAMS() - 1
    nrows = N_ELEMENTS(Data1)

    switch (nfields) of
      8: if (N_ELEMENTS(Data8) ne nrows) then MESSAGE, msg
      7: if (N_ELEMENTS(Data7) ne nrows) then MESSAGE, msg
      6: if (N_ELEMENTS(Data6) ne nrows) then MESSAGE, msg
      5: if (N_ELEMENTS(Data5) ne nrows) then MESSAGE, msg
      4: if (N_ELEMENTS(Data4) ne nrows) then MESSAGE, msg
      3: if (N_ELEMENTS(Data3) ne nrows) then MESSAGE, msg
      2: if (N_ELEMENTS(Data2) ne nrows) then MESSAGE, msg
      else:
    endswitch

  endelse


  <span class="comments">; Verify that the header (if provided) has the correct number of elements.</span>

  nheader = N_Elements(header)
  if (nheader gt 0) then begin
    <span class="comments">; Quietly ignore null strings.</span>
    if (ARRAY_EQUAL(header,'')) then begin
      nheader = 0
    endif else begin
      if (nheader ne nfields || SIZE(header,/type) ne 7) then begin
        MESSAGE, 'HEADER must be a string array of length equal to the number of columns.'
      endif
    endelse
  endif


  <span class="comments">; Start writing the file.</span>

  OPENW, lun, filename, /GET_LUN,append=append
  <span class="comments">; What about handling COMMAS or QUOTES?!</span>

  format = (nfields ge 2) ? '(' + STRTRIM(nfields-1,2)+'(A,","),A)' : '(A)'

  <span class="comments">; Printing out extra headers to csv file</span>
  if n_elements(tableHeader) gt 0 then begin
    for i=0, n_elements(tableHeader)-1 do begin
      <span class="comments">;check if there is comma in the string</span>
      posComma = stregex(tableHeader[i], ',')
      posQuote = stregex(tableHeader[i], '"')
      if (posComma eq -1) && (posQuote eq -1) then printf, lun, tableHeader[i], FORMAT=format else printf, lun, '"' + tableHeader[i] + '"', FORMAT=format
    endfor
  endif

  if (nheader gt 0) then begin
    PRINTF, lun, header, FORMAT=format
  endif


  if (isStruct) then begin  <span class="comments">; Structure fields</span>

    strCopy = STRARR(nfields, nrows)

    for i=0,nfields-1 do begin
      strCopy[i,*] = WRITE_CSV_CONVERT_pp_original(Data1.(i),noquote=noquote)
    endfor

    PRINTF, lun, strCopy, FORMAT=format

  endif else if (isArray) then begin  <span class="comments">; Two-dimensional array</span>

    PRINTF, lun, WRITE_CSV_CONVERT_pp_original(Data1,noquote=noquote), FORMAT=format

  endif else begin  <span class="comments">; Individual data arguments</span>

    strCopy = STRARR(nfields, nrows)

    switch (nfields) of
      8: strCopy[7,*] = WRITE_CSV_CONVERT_pp_original(Data8,noquote=noquote)
      7: strCopy[6,*] = WRITE_CSV_CONVERT_pp_original(Data7,noquote=noquote)
      6: strCopy[5,*] = WRITE_CSV_CONVERT_pp_original(Data6,noquote=noquote)
      5: strCopy[4,*] = WRITE_CSV_CONVERT_pp_original(Data5,noquote=noquote)
      4: strCopy[3,*] = WRITE_CSV_CONVERT_pp_original(Data4,noquote=noquote)
      3: strCopy[2,*] = WRITE_CSV_CONVERT_pp_original(Data3,noquote=noquote)
      2: strCopy[1,*] = WRITE_CSV_CONVERT_pp_original(Data2,noquote=noquote)
      1: strCopy[0,*] = WRITE_CSV_CONVERT_pp_original(Data1,noquote=noquote)
    endswitch

    PRINTF, lun, strCopy, FORMAT=format

  endelse

  FREE_LUN, lun

  return

  ioerr:
  ON_IOERROR, null
  if (N_ELEMENTS(lun) gt 0) then $
    FREE_LUN, lun
  MESSAGE, !ERROR_STATE.msg

end


<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    A simple wrapper for write_csv, to write csv files using a structure's field names as column</span>
<span class="comments">;    titles (setting `titlesfromfields`), ccepting nested structures, and with the option of writing the</span>
<span class="comments">;    file by pieces.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    file: in, required, type=string</span>
<span class="comments">;      Passed to write_csv, specifies the name of the file to write.</span>
<span class="comments">;    data1: in, required</span>
<span class="comments">;      Passed to write_csv, after the variable has its structures flattened by a call to</span>
<span class="comments">;      `pp_struct_unravel`.</span>
<span class="comments">;    data2: in, optional</span>
<span class="comments">;      Passed unaltered to write_csv.</span>
<span class="comments">;    data3: in, optional</span>
<span class="comments">;      Passed unaltered to write_csv.</span>
<span class="comments">;    data4: in, optional</span>
<span class="comments">;      Passed unaltered to write_csv.</span>
<span class="comments">;    data5: in, optional</span>
<span class="comments">;      Passed unaltered to write_csv.</span>
<span class="comments">;    data6: in, optional</span>
<span class="comments">;      Passed unaltered to write_csv.</span>
<span class="comments">;    data7: in, optional</span>
<span class="comments">;      Passed unaltered to write_csv.</span>
<span class="comments">;    data8: in, optional</span>
<span class="comments">;      Passed unaltered to write_csv.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    titlesfromfields: in, optional</span>
<span class="comments">;      If set, the column titles in the csv file are made by the field names in data1.</span>
<span class="comments">;    verbose: in, optional, default=0</span>
<span class="comments">;      If set, write_csv_pp will inform which piece of the file it is currently writing</span>
<span class="comments">;    divide: in, optional, default=1</span>
<span class="comments">;      Used to split the file writing into ``divide`` pieces. This is useful to save memory, since</span>
<span class="comments">;      IDL's ``write_csv`` creates a temporary string array with the whole file contents, before writing it</span>
<span class="comments">;      to the file, and that array can be several times larger than the input array.</span>
<span class="comments">;    noquote: in, optional, default=0</span>
<span class="comments">;      If set, string fields that do not contain commas or double-quotes will not</span>
<span class="comments">;      be quoted. If not set (default), all string fields are quoted.</span>
<span class="comments">;    _ref_extra: in, out, optional</span>
<span class="comments">;      Any other parameters are passed, unaltered, to / from write_csv.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Make a simple structure array and write it to a csv file::</span>
<span class="comments">;</span>
<span class="comments">;      s={a:1,b:{c:2.5,d:-9,e:0},f:1.8,g:'h'}</span>
<span class="comments">;      s2=replicate(s,2)</span>
<span class="comments">;      s2[1].a=-1</span>
<span class="comments">;      s2[1].f=-1.8</span>
<span class="comments">;      s2[1].g='h,i'</span>
<span class="comments">;      write_csv_pp,'write_csv_pp_test.csv',s2,/titlesfromfields</span>
<span class="comments">;</span>
<span class="comments">;    Which result in a file with:</span>
<span class="comments">;</span>
<span class="comments">;    A,B_C,B_D,B_E,F,G</span>
<span class="comments">;    </span>
<span class="comments">;    1,2.50000,-9,0,1.80000,"h"</span>
<span class="comments">;    </span>
<span class="comments">;    -1,2.50000,-9,0,-1.80000,"h,i"</span>
<span class="comments">;    </span>
<span class="comments">;    Compare with using the `noquote` keyword:</span>
<span class="comments">;    </span>
<span class="comments">;      write_csv_pp,'write_csv_pp_test.csv',s2,/titlesfromfields,/noquote</span>
<span class="comments">;      </span>
<span class="comments">;    Which produces</span>
<span class="comments">;    </span>
<span class="comments">;    A,B_C,B_D,B_E,F,G</span>
<span class="comments">;    </span>
<span class="comments">;    1,2.50000,-9,0,1.80000,h</span>
<span class="comments">;    </span>
<span class="comments">;    -1,2.50000,-9,0,-1.80000,"h,i"</span>
<span class="comments">;    </span>
<span class="comments">;    On the first row, the string (the last column) is unquoted. On the second,</span>
<span class="comments">;    it is still quoted because it contains a comma; without this quote, it</span>
<span class="comments">;    would look like the row has an extra column.</span>
<span class="comments">;</span>
<span class="comments">; :Requires: `pp_struct_unravel`</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (`http://www.ppenteado.net &lt;http://www.ppenteado.net>`), Feb/2013</span>
<span class="comments">;-</span>
<a id="write_csv_pp:source"></a>pro write_csv_pp,file,data1,data2,data3,data4,data5,data6,data7,data8,titlesfromfields=tf,$
  divide=divide,_ref_extra=ex,verbose=verbose,noquote=noquote
  compile_opt idl2,logical_predicate
  
  noquote=keyword_set(noquote)
  divide=n_elements(divide) ? divide : 1LL
  nrows=n_elements(data1)
  blocksize=ceil(nrows*1d0/divide)
  nd=ceil(nrows*1d0/blocksize)
  
  u=pp_struct_unravel(data1,/testonly)
  if u then data0=pp_struct_unravel(data1)
  for i=0LL,nd-1 do begin
    fr=i*blocksize
    lr=((i+1LL)*blocksize-1)&lt;(nrows-1LL)
    if keyword_set(verbose) then print,'write_csv_pp: writing file section ',strtrim(i+1,2),' of ',strtrim(nd,2)
    if keyword_set(tf) then begin
      header=tag_names(u ? data0 : data1)
      write_csv_pp_original,file,(u ? data0[fr:lr] : data1[fr:lr]),$
        n_elements(data2) ? data2[fr:lr] : !null ,$
        n_elements(data3) ? data3[fr:lr] : !null ,$
        n_elements(data4) ? data4[fr:lr] : !null ,$
        n_elements(data5) ? data5[fr:lr] : !null ,$
        n_elements(data6) ? data6[fr:lr] : !null ,$
        n_elements(data7) ? data7[fr:lr] : !null ,$
        n_elements(data8) ? data8[fr:lr] : !null ,$
        _strict_extra=ex,header=(i eq 0 ? header : !null),append=i,noquote=noquote
    endif else begin
      write_csv_pp_original,file,(u ? data0[fr:lr] : data1[fr:lr]),$
        n_elements(data2) ? data2[fr:lr] : !null ,$
        n_elements(data3) ? data3[fr:lr] : !null ,$
        n_elements(data4) ? data4[fr:lr] : !null ,$
        n_elements(data5) ? data5[fr:lr] : !null ,$
        n_elements(data6) ? data6[fr:lr] : !null ,$
        n_elements(data7) ? data7[fr:lr] : !null ,$
        n_elements(data8) ? data8[fr:lr] : !null ,$
        _strict_extra=ex,append=i,noquote=noquote
    endelse
  endfor
end

</code>
    </div>
  </body>
</html>