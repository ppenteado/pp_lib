<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue May 16 12:42:27 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pp_resample.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pp_resample.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Feb/2010</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Examples to test and illustrate the different behaviors of pp_resample.</span>
<span class="comments">;    </span>
<span class="comments">;    Makes up a high resolution Gaussian line and resamples at nr locations (defaults to 15).</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    nr : in, optional, default=15</span>
<span class="comments">;      The number of locations where the function is to be resampled at.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;   Run the pp_resample_test routine, to compare the different methods, at different resampling resolution::</span>
<span class="comments">;   </span>
<span class="comments">;      .com pp_resample ;pp_resample_test is in pp_resample.pro, so it will not be found by itself</span>
<span class="comments">;      pp_resample_test,15 ;At this resolution, the local mode is still reasonable.</span>
<span class="comments">;      sigma:    7.6632088e-09   6.6129373e-11   1.1358731e-13</span>
<span class="comments">;      Trapezoidal areas</span>
<span class="comments">;               New grid   Original areas  Resampled areas</span>
<span class="comments">;          -3.700000E+00     0.000000E+00     0.000000E+00</span>
<span class="comments">;          -3.128571E+00     8.421810E-05     8.421810E-05</span>
<span class="comments">;          -2.557143E+00     2.646517E-03     2.731632E-03</span>
<span class="comments">;          -1.985714E+00     4.414658E-02     4.425478E-02</span>
<span class="comments">;          -1.414286E+00     4.031373E-01     4.035549E-01</span>
<span class="comments">;          -8.428571E-01     2.067294E+00     2.069880E+00</span>
<span class="comments">;          -2.714286E-01     6.213192E+00     6.223648E+00</span>
<span class="comments">;           3.000000E-01     1.177465E+01     1.179997E+01</span>
<span class="comments">;           8.714286E-01     1.579429E+01     1.583423E+01</span>
<span class="comments">;           1.442857E+00     1.735853E+01     1.740596E+01</span>
<span class="comments">;           2.014286E+00     1.768562E+01     1.773506E+01</span>
<span class="comments">;           2.585714E+00     1.772227E+01     1.777198E+01</span>
<span class="comments">;           3.157143E+00     1.772447E+01     1.777420E+01</span>
<span class="comments">;           3.728571E+00     1.772454E+01     1.777427E+01</span>
<span class="comments">;           4.300000E+00     1.772454E+01     1.777427E+01</span>
<span class="comments">;      Rectangular areas</span>
<span class="comments">;                  Start              End   Original areas  Resampled areas</span>
<span class="comments">;          -3.985714E+00    -3.414286E+00     1.217446E-05     1.217446E-05</span>
<span class="comments">;          -3.414286E+00    -2.842857E+00     5.196621E-04     1.176678E-02</span>
<span class="comments">;          -2.842857E+00    -2.271429E+00     1.176170E-02     1.446414E-01</span>
<span class="comments">;          -2.271429E+00    -1.700000E+00     1.445446E-01     9.845714E-01</span>
<span class="comments">;          -1.700000E+00    -1.128571E+00     9.835830E-01     3.834577E+00</span>
<span class="comments">;          -1.128571E+00    -5.571429E-01     3.829106E+00     9.038319E+00</span>
<span class="comments">;          -5.571429E-01     1.428571E-02     9.021113E+00     1.415784E+01</span>
<span class="comments">;           1.428571E-02     5.857143E-01     1.412464E+01     1.687159E+01</span>
<span class="comments">;           5.857143E-01     1.157143E+00     1.682703E+01     1.764558E+01</span>
<span class="comments">;           1.157143E+00     1.728571E+00     1.759682E+01     1.776405E+01</span>
<span class="comments">;           1.728571E+00     2.300000E+00     1.771449E+01     1.777375E+01</span>
<span class="comments">;           2.300000E+00     2.871429E+00     1.772411E+01     1.777418E+01</span>
<span class="comments">;           2.871429E+00     3.442857E+00     1.772453E+01     1.777419E+01</span>
<span class="comments">;           3.442857E+00     4.014286E+00     1.772454E+01     1.777419E+01</span>
<span class="comments">;           4.014286E+00     4.585714E+00     1.772454E+01     1.777419E+01</span>
<span class="comments">;      pp_resample_test,5  ;At this resolution, the local mode gives an ugly result, but non local is still good.</span>
<span class="comments">;      sigma:    7.7028521e-09   6.6471473e-11   1.1417492e-13</span>
<span class="comments">;      Trapezoidal areas</span>
<span class="comments">;               New grid   Original areas  Resampled areas</span>
<span class="comments">;          -3.700000E+00     0.000000E+00    -0.000000E+00</span>
<span class="comments">;          -1.700000E+00     1.436523E-01     1.436523E-01</span>
<span class="comments">;           3.000000E-01     1.177465E+01     1.191919E+01</span>
<span class="comments">;           2.300000E+00     1.771441E+01     1.787357E+01</span>
<span class="comments">;           4.300000E+00     1.772454E+01     1.788378E+01</span>
<span class="comments">;      Rectangular areas</span>
<span class="comments">;                  Start              End   Original areas  Resampled areas</span>
<span class="comments">;          -4.700000E+00    -2.700000E+00     1.201453E-03     1.201453E-03</span>
<span class="comments">;          -2.700000E+00    -7.000000E-01     2.865225E+00     1.715248E+01</span>
<span class="comments">;          -7.000000E-01     1.300000E+00     1.714266E+01     1.773729E+01</span>
<span class="comments">;           1.300000E+00     3.300000E+00     1.772451E+01     1.773732E+01</span>
<span class="comments">;           3.300000E+00     5.300000E+00     1.772454E+01     1.773735E+01</span>
<span class="comments">;      </span>
<span class="comments">;   .. image:: pp_resample_test_1.png</span>
<span class="comments">;   .. image:: pp_resample_test_2.png</span>
<span class="comments">;      </span>
<span class="comments">; :Uses: pp_resample, pp_integral</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Feb/2010</span>
<span class="comments">;-</span>
<a id="pp_resample_test:source"></a>pro pp_resample_test,nr
compile_opt idl2,hidden
<span class="comments">;Defaults</span>
nr=n_elements(nr) eq 1 ? nr : 15

<span class="comments">;Make up a well sampled test function and plot it</span>
<span class="comments">;This function has so many points that if nr is much smaller than nx, it does not matter whether it is seen</span>
<span class="comments">;as a literal or sampled function</span>
nx=10001
x=(dindgen(nx)/(nx-1d0))*16d0-8d0
y=1d1*exp(-x^2)
iplot,x,y,/isotropic,thick=3.,name='Original function (literal)',/insert_legend,$
 title='Original function at '+strtrim(string(nx),2)+' points, resampled at '+strtrim(string(nr),2)+' points' 
<span class="comments">;Make up a grid to resample to</span>
xout=(dindgen(nr)/(nr-1d0))*8d0-3.7d0
areas1=pp_integral(x,y,xmin=replicate(xout[0],nr),xmax=xout,/local)
<span class="comments">;Resample with rectangles (local=0) and plot it</span>
yout=pp_resample(y,x,xout,xstart=xstart,xend=xend,xoutbox=xoutbox,youtbox=youtbox)
areas0=pp_integral(x,y,xmin=replicate(xstart[0],nr),xmax=xend)
areas2=pp_integral(xout,yout,/cumulative)
iplot,xoutbox,youtbox,/over,color=[0,0,255],thick=2.,name='Resampled function (sampled)',/insert_legend
iplot,xout,yout,/over,color=[0,255,0],thick=2.,name='Resampled locations (sampled)',/insert_legend,sym_ind=6,sym_size=2.
<span class="comments">;Resample with trapezoids (local=1) and plot it</span>
yout2=pp_resample(y,x,xout,/local)
areas3=pp_integral(xout,yout2,/cumulative,/local)
iplot,xout,yout2,/over,color=[255,0,0],name='Resampled function (literal)',/insert_legend,sym_ind=4,sym_size=2.
print,'Trapezoidal areas'
print,'New grid','Original areas','Resampled areas',format='(3A17)'
for i=0,nr-1 do print,xout[i],areas1[i],areas3[i],format='(3E17.6)'
print,'Rectangular areas'
print,'Start','End','Original areas','Resampled areas',format='(4A17)'
for i=0,nr-1 do print,xstart[i],xend[i],areas0[i],areas2[i],format='(4E17.6)'

end


<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Resamples the given y(x) function, preserving its area (not just a simple interpolation</span>
<span class="comments">;    of the function points, as interpol would do). By default (local=0), each input y(x) is</span>
<span class="comments">;    interpreted a measured sample, that is, as the average of the "flux" falling inside the region</span>
<span class="comments">;    centered at the corresponding x value: x locations are interpreted as the centers of bins. The same</span>
<span class="comments">;    interpretation is used for the output locations (xout), and the returned results. See the plots in</span>
<span class="comments">;    the example for a graphical demonstration.</span>
<span class="comments">;    </span>
<span class="comments">;    A literal interpretation of the function (setting the keyword local), as pp_integral does, is intended,</span>
<span class="comments">;    but not yet properly implemented, so the local mode should not be used at this time.</span>
<span class="comments">;    The input values must be ordered in x (it does not matter whether it is increasing or decreasing order). </span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    An array with the same length as xout, with the input function resampled at those locations.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    y : in, required</span>
<span class="comments">;      An array with the function values corresponding to the locations in x.</span>
<span class="comments">;    x : in, required</span>
<span class="comments">;      An array of locations where the function is sampled. Must be ordered (increasing or decreasing).</span>
<span class="comments">;    xout : in, required</span>
<span class="comments">;      An array of the locations where the y(x) function is to be resampled.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    xstart : out, optional</span>
<span class="comments">;      Used when not in local mode, to return the start locations of the bins with center in xout.</span>
<span class="comments">;    xend : out, optional</span>
<span class="comments">;      Used when not in local mode, to return the end locations of the bins with center in xout.</span>
<span class="comments">;    xbox : out, optional</span>
<span class="comments">;      Used when not in local mode, to return the input x values in pairs of equal values, so that</span>
<span class="comments">;      plotting xbox,ybox shows the rectangles that are how the input values were interpreted.</span>
<span class="comments">;    ybox : out, optional</span>
<span class="comments">;      Used when not in local mode, to return the input y values in pairs of equal values, so that</span>
<span class="comments">;      plotting xbox,ybox shows the rectangles that are how the input values were interpreted.</span>
<span class="comments">;    xoutbox : out, optional</span>
<span class="comments">;      Used when not in local mode, to return the resampled x values in pairs of equal values, so that</span>
<span class="comments">;      plotting xoutbox,youtbox shows the rectangles that are how the resampled values are to be interpreted.</span>
<span class="comments">;    youtbox : out,optional</span>
<span class="comments">;      Used when not in local mode, to return the resampled y values in pairs of equal values, so that</span>
<span class="comments">;      plotting xoutbox,youtbox shows the rectangles that are how the resampled values are to be interpreted.</span>
<span class="comments">;    local : in, optional, default=0</span>
<span class="comments">;      If not set, the y values are interpreted as a measured sample, that is, as the average of the "flux" falling inside the region</span>
<span class="comments">;      centered at the corresponding x values: x locations are interpreted as the centers of bins. Since this interpretation is equivalent</span>
<span class="comments">;      to a literal interpretation of a function made of rectangular regions, in this method there are no interpolations (partial areas, if</span>
<span class="comments">;      any, are just the corresponding fractions of the rectangles). The returned values are to be interpreted in the same way, that is,</span>
<span class="comments">;      they represent rectangular bins, which have the same area as the rectangular bins in the corresponding region of the input function.</span>
<span class="comments">;      </span>
<span class="comments">;      If set, interprets the function literally. The result is a function where the area between each of its</span>
<span class="comments">;      points (at xout) is the same as the area of y(x) between these locations.  </span>
<span class="comments">;    newton : in, optional, default=0</span>
<span class="comments">;      Passed on to pp_integral. If local is set and newton is set, the function integrations are done with int_tabulated, which</span>
<span class="comments">;      uses a 5 point Newton-Cotes formula. If local is not set, this has no effect.</span>
<span class="comments">;    p0 : in, default=4</span>
<span class="comments">;      Parameter for the local mode. It should not be necessary to change it from the default, and it should disappear</span>
<span class="comments">;      in future implementations. It is the number of points to use for the numeric evaluation of a function's</span>
<span class="comments">;      minimum, but the result is not expected to vary for p0 larger than 3, as the function is expected to be</span>
<span class="comments">;      an exact parabola.</span>
<span class="comments">;    lsquadratic : in, optional, default=0</span>
<span class="comments">;      Passed on to pp_integral. If the method requires interpolation, this is passed on to interpol,</span>
<span class="comments">;      to select 4 point quadratic interpolation.</span>
<span class="comments">;      If none of lsquadratic, quadratic and spline are set, interpolation is linear. </span>
<span class="comments">;    quadratic : in, optional, default=0</span>
<span class="comments">;      Passed on to pp_integral. If the method requires interpolation, this is passed on to interpol,</span>
<span class="comments">;      to select 3 point quadratic interpolation.</span>
<span class="comments">;      If none of lsquadratic, quadratic and spline are set, interpolation is linear.</span>
<span class="comments">;    spline : in, optional, default=0</span>
<span class="comments">;      Passed on to pp_integral. If the method requires interpolation, this is passed on to interpol,</span>
<span class="comments">;      to select spline interpolation.</span>
<span class="comments">;      If none of lsquadratic, quadratic and spline are set, interpolation is linear.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">; </span>
<span class="comments">;   Make a well-sampled input function y(x) and an output grid xout with few locations::</span>
<span class="comments">;   </span>
<span class="comments">;     x=dindgen(10001)/1d4-0.5d0</span>
<span class="comments">;     y=exp(-(x*2d1)^2)*0.5d0</span>
<span class="comments">;     xout=dindgen(5)/6d0-0.3d0</span>
<span class="comments">;     </span>
<span class="comments">;   Do the resampling and look at the results::</span>
<span class="comments">;   </span>
<span class="comments">;     yout=pp_resample(y,x,xout,xstart=xstart,xend=xend,xbox=xbox,ybox=ybox,xoutbox=xoutbox,youtbox=youtbox)</span>
<span class="comments">;     print,xstart,xend</span>
<span class="comments">;     ;-0.38333333     -0.21666667    -0.050000000      0.11666667      0.28333333</span>
<span class="comments">;     ;-0.21666667    -0.050000000      0.11666667      0.28333333      0.45000000</span>
<span class="comments">;     print,xstart,xend</span>
<span class="comments">;     ;-0.38333333     -0.21666667    -0.050000000      0.11666667      0.28333333</span>
<span class="comments">;     ;-0.21666667    -0.050000000      0.11666667      0.28333333      0.45000000</span>
<span class="comments">;     iplot,xbox,ybox,name='input function (rectangles)',/insert_legend,thick=2.</span>
<span class="comments">;     iplot,xoutbox,youtbox,/over,color=[255,0,0],name='resampled function (rectangles)',/insert_legend,thick=2.</span>
<span class="comments">;     iplot,xout,yout,/over,color=[0,255,0],name='resampled function (locations)',/insert_legend,thick=2.</span>
<span class="comments">;     </span>
<span class="comments">;   .. image:: pp_resample.png</span>
<span class="comments">;</span>
<span class="comments">;   See also the example in pp_resample_test, for a comparison of the methods.</span>
<span class="comments">;</span>
<span class="comments">; :Uses: pp_integral</span>
<span class="comments">;</span>
<span class="comments">; :Todo:</span>
<span class="comments">;   Improve the implementation of the resampling when local is set, to get replace the numerical</span>
<span class="comments">;   minimization by an analytic expression.</span>
<span class="comments">;   </span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Feb/2010</span>
<span class="comments">;-</span>
<a id="pp_resample:source"></a>function pp_resample,y,x,xout,xstart=xstart,xend=xend,xbox=xbox,ybox=ybox,xoutbox=xoutbox,youtbox=youtbox,$
 local=local,newton=newton,p0=p0,$
 lsquadratic=lsquadratic,quadratic=quadratic,spline=spline
compile_opt idl2

<span class="comments">;Check that the input is valid</span>
nx=n_elements(xout)
if (nx lt 2L) then message,'Output grid xout must contain more than two points'

<span class="comments">;Defaults</span>
local=n_elements(local) eq 1 ? local : 0
p0=n_elements(p0) eq 1 ? p0 : 4

if (~local) then begin <span class="comments">;Interpret the functions as sample averages</span>
  <span class="comments">;Calculate the start and en of each output point</span>
  xstart=[xout[0]-(xout[1]-xout[0])/2d0,(xout[0:nx-2]+xout[1:nx-1])/2d0]
  xend=[xstart[1:nx-1],xout[nx-1]+(xout[nx-1]-xout[nx-2])/2d0]
  <span class="comments">;Get area between the start and end of each output point</span>
  areas=pp_integral(x,y,xmin=xstart,xmax=xend,xstart=ixstart,xend=ixend,yinc=yinc,$
   local=local,newton=newton,lsquadratic=lsquadratc,quadratic=quadratic,spline=spline)
  <span class="comments">;Calculate the function average over the span of each output point </span>
  ret=areas/(xend-xstart)
  <span class="comments">;Create xoutbox and youtbox arrays, with constant y values spanning the start and end of each xout point</span>
  if (arg_present(xoutbox) || arg_present(youtbox)) then begin
    xoutbox=dblarr(2L*nx) & youtbox=dblarr(2L*nx)
    xoutbox[0:*:2]=xstart & xoutbox[1:*:2]=xend
    youtbox[0:*:2]=ret & youtbox[1:*:2]=ret
  endif
endif else begin <span class="comments">;Interpret the functions literally</span>
  <span class="comments">;Calculate the cumulative areas at each point on the input function</span>
  areas=pp_integral(x,y,/local,xmin=xout[0:nx-2],xmax=xout[1:nx-1],newton=newton,lsquadratic=lsquadratc,quadratic=quadratic,spline=spline)
  <span class="comments">;Numerical determination of the smallest line with the same area as the input function</span>
  yf=sqrt(total(y^2))
  yf=yf gt 0d0 ? yf : 1d0
  r0=yf*dindgen(p0)/(p0-1d0)*2d0-1d0
  tmp=2d0*areas[0:nx-2]/(xout[1:nx-1]-xout[0:nx-2])
  ret=dblarr(nx)
  rms=dblarr(p0)
  for i=0,p0-1 do begin
    ret[0]=r0[i]
    for j=1,nx-1 do ret[j]=tmp[j-1]-ret[j-1]
    rms[i]=total(ret^2)
  endfor
  <span class="comments">;rms(r0) should be a parabola, so fit a parabola to find its minimum</span>
  pol=poly_fit(r0,rms,2,/double,sigma=sigma)
  print,'sigma: ',sigma <span class="comments">;Uncertainties on the parabola parameters</span>
  <span class="comments">;Recalculate the line with the r that produces the smallest line </span>
  ret[0]=-pol[1]/(2d0*pol[2])
  for j=1,nx-1 do ret[j]=tmp[j-1]-ret[j-1]
endelse

<span class="comments">;Create xbox and ybox arrays, with constant y values spanning the start and end of each x point</span>
if (arg_present(xbox) || arg_present(ybox)) then begin
  nix=n_elements(x)
  xbox=dblarr(2L*nix) & ybox=dblarr(2L*nix)
  xbox[0:*:2]=ixstart & xbox[1:*:2]=ixend
  ybox[0:*:2]=yinc & ybox[1:*:2]=yinc
endif

return,ret
end
</code>
    </div>
  </body>
</html>