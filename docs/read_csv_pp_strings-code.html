<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue May 16 12:42:28 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>read_csv_pp_strings.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="read_csv_pp_strings.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'idl'</span>
<span class="comments">; $Id: //depot/Release/ENVI50_IDL82/idl/idldir/lib/read_csv.pro#2 $</span>
<span class="comments">;</span>
<span class="comments">; Copyright (c) 2008-2012, Exelis Visual Information Solutions, Inc. All</span>
<span class="comments">;       rights reserved. Unauthorized reproduction is prohibited.</span>

<span class="comments">;----------------------------------------------------------------------------</span>
<a id="read_csv_fieldnames:source"></a>function read_csv_fieldnames, fieldCount

  compile_opt idl2, hidden
  
  digits_str = STRTRIM(STRING(STRLEN(STRTRIM(STRING(fieldCount),2))),2)
  fstr = '(i' + digits_str + '.' + digits_str + ')'
  fieldNames   = 'field' + STRING(LINDGEN(fieldCount)+1, FORMAT=fstr)
  
  return, fieldNames
end

<span class="comments">;----------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    The READ_CSV function reads data from a "comma-separated value"</span>
<span class="comments">;    (comma-delimited) text file into an IDL structure variable.</span>
<span class="comments">;</span>
<span class="comments">;    This routine handles CSV files consisting of an optional line of column</span>
<span class="comments">;    headers, followed by columnar data, with commas separating each field.</span>
<span class="comments">;    Each row is assumed to be a new record.</span>
<span class="comments">;    </span>
<span class="comments">;    The READ_CSV routine will automatically return each column (or field)</span>
<span class="comments">;    in the correct IDL variable type using the following rules:</span>
<span class="comments">;    </span>
<span class="comments">;       * Long - All data within that column consists of integers,</span>
<span class="comments">;           all of which are smaller than the maximum 32-bit integer.</span>
<span class="comments">;       * Long64 - All data within that column consists of integers,</span>
<span class="comments">;           with at least one greater than the maximum 32-bit integer.</span>
<span class="comments">;       * Double - All data within that column consists of numbers, at least</span>
<span class="comments">;           one of which has either a decimal point or an exponent.</span>
<span class="comments">;       * String - All data which does not fit into one of the above types.</span>
<span class="comments">;       </span>
<span class="comments">;    This routine is written in the IDL language. Its source code can be</span>
<span class="comments">;    found in the file read_csv.pro in the lib subdirectory of the IDL</span>
<span class="comments">;    distribution. </span>
<span class="comments">;</span>
<span class="comments">; :Syntax:</span>
<span class="comments">;    Result = READ_CSV( Filename</span>
<span class="comments">;      [, COUNT=variable] [, HEADER=variable] [, MISSING_VALUE=value]</span>
<span class="comments">;      [, NUM_RECORDS=value] [, RECORD_START=value]</span>
<span class="comments">;      [, N_TABLE_HEADER=value] [,TABLE_HEADER=variable]</span>
<span class="comments">;      )</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    Filename</span>
<span class="comments">;      A string containing the name of a CSV file to read into an IDL variable.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    COUNT</span>
<span class="comments">;      Set this keyword equal to a named variable that will contain the</span>
<span class="comments">;      number of records read.</span>
<span class="comments">;      </span>
<span class="comments">;    HEADER</span>
<span class="comments">;      Set this keyword equal to a named variable that will contain the</span>
<span class="comments">;      column headers as a vector of strings. If no header exists,</span>
<span class="comments">;      an empty scalar string is returned.</span>
<span class="comments">;      </span>
<span class="comments">;    MISSING_VALUE</span>
<span class="comments">;      Set this keyword equal to a value used to replace any missing</span>
<span class="comments">;      floating-point or integer data. The default value is 0.</span>
<span class="comments">;      </span>
<span class="comments">;    NUM_RECORDS</span>
<span class="comments">;      Set this keyword equal to the number of records to read.</span>
<span class="comments">;      The default is to read all records in the file.</span>
<span class="comments">;      </span>
<span class="comments">;    RECORD_START</span>
<span class="comments">;      Set this keyword equal to the index of the first record to read.</span>
<span class="comments">;      The default is the first record of the file (record 0).</span>
<span class="comments">;      </span>
<span class="comments">;    N_TABLE_HEADER    </span>
<span class="comments">;       Set this keyword to the number of lines to skip at the beginning of the file, </span>
<span class="comments">;       not including the HEADER line. These extra lines may be retrieved by using the TABLE_HEADER keyword.</span>
<span class="comments">;       </span>
<span class="comments">;    TABLE_HEADER</span>
<span class="comments">;       Set this keyword to a named variable in which to return an array of strings </span>
<span class="comments">;       containing the extra table headers at the beginning of the file, as specified by N_TABLE_HEADER.</span>
<span class="comments">;      </span>
<span class="comments">; :History:</span>
<span class="comments">;   Written, CT, VIS, Oct 2008</span>
<span class="comments">;   MP, VIS, Oct 2009: Added keyword NSKIP and SKIP_HEADER</span>
<span class="comments">;   </span>
<span class="comments">;-</span>
<a id="read_csv_pp_strings:source"></a>function read_csv_pp_strings, Filename, $
  COUNT=count, $
  HEADER=header, $
  MISSING_VALUE=missingValue, $
  NUM_RECORDS=numRecordsIn, $
  RECORD_START=recordStart, $
  N_TABLE_HEADER=nTableHeader, $
  TABLE_HEADER=tableHeader, $
  _EXTRA=_extra,$  <span class="comments">; needed for iOpen</span>
  <span class="comments">;New parameters, by Paulo Penteado (http://www.ppenteado.net):</span>
  types=types,$ <span class="comments">;if provided, assume these types codes for the columns, instead of trying to determine</span>
  nan=nan,infinity=infinity,integer=integer,trim=trim,blank=blank,$ <span class="comments">;passed to pp_isnumber when testing columns</span>
  rows_for_testing=rows_for_testing <span class="comments">;Maximum number of rows to use when testing columns for data types.</span>
                                    <span class="comments">;Set to zero to test all rows</span>
  

  compile_opt idl2, hidden

  <span class="comments">;ON_ERROR, 2         ;Return on error</span>

  CATCH, err
  if (err ne 0) then begin
    CATCH, /CANCEL
    if (N_ELEMENTS(lun) gt 0) then $
      FREE_LUN, lun
    if (MAX(PTR_VALID(pData)) eq 1) then $
      PTR_FREE, pData
    MESSAGE, !ERROR_STATE.msg
  endif

  header = ''

  if (N_PARAMS() eq 0) then $
    MESSAGE, 'Incorrect number of arguments.'
  
  <span class="comments">; Empty file</span>
  if (FILE_TEST(filename, /ZERO_LENGTH)) then $
    return, 0

  <span class="comments">;Set appropriate dataStart, where dataStart includes column header.</span>
  dataStart = keyword_set(nTableHeader) ? LONG64(nTableHeader) : 0
  
  OPENR, lun, filename, /GET_LUN

  str = ''
  tableHeader=''
  for i=0L, dataStart do begin
    READF, lun, str
    if i ne dataStart then begin
      pos = stregex(str, '"') 
      if pos ne 0 then begin <span class="comments">; string not enclosed in quotes</span>
        pos = stregex(str, ',+')<span class="comments">; check for extra commas</span>
        if pos ne -1 then str = strmid(str, 0, pos) 
      endif else begin
        <span class="comments">; string enclosed in commas</span>
        pos = stregex(str, '",+') <span class="comments">; check for extra commas</span>
        if pos ne -1 then str = strmid(str, 1, pos-1) else str = strjoin(strsplit(str, '"', /EXTRACT))
      endelse
      
      if i eq 0 then tableHeader = str else tableHeader = [tableHeader, str]
    endif
  endfor
  
  while (STRLEN(STRTRIM(str,2)) eq 0) do begin
    READF, lun, str
  endwhile
  
  FREE_LUN, lun
  
  <span class="comments">; We need to count the number of fields.</span>
  <span class="comments">; First remove escaped quote characters, which look like "".</span>
  str = STRJOIN(STRTOK(str, '""', /REGEX, /EXTRACT))
  <span class="comments">; Now remove quoted strings, which might contain bogus commas.</span>
  str = STRJOIN(STRTOK(str,'"[^"]*"', /REGEX, /EXTRACT))
  <span class="comments">; Finally, count the number of commas.</span>
  fieldCount = N_Elements(STRTOK(str, ',', /PRESERVE_NULL))

  fieldNames = Read_CSV_Fieldnames(fieldCount)

  template = { $
    version:         1.0, $
    dataStart:       dataStart, $  <span class="comments">; specified as a keyword below</span>
    delimiter:       BYTE(','), $  <span class="comments">; comma-separated</span>
    missingValue:    0, $
    commentSymbol:   '', $
    fieldCount:      fieldCount, $
    fieldTypes:      REPLICATE(7L, fieldCount), $
    fieldNames:      fieldNames, $
    fieldLocations:  LONARR(fieldCount), $  <span class="comments">; ignored for csv</span>
    fieldGroups:     LINDGEN(fieldCount) $  <span class="comments">; ungrouped</span>
  }

  if (N_Elements(numRecordsIn)) then $
    numRecords = numRecordsIn[0] + 1

  data = READ_ASCII(filename, /CSV, $
    COUNT=count, $
    DATA_START=dataStart, $
    NUM_RECORDS=numRecords, $
    RECORD_START=recordStart, $
    TEMPLATE=template)

  if (N_TAGS(data) eq 0) then $
    MESSAGE, 'File "' + filename + '" is not a valid CSV file.', /NONAME

  <span class="comments">; Eliminate empty columns</span>
  columnLen = LONARR(fieldCount)
  firstNonEmptyRow = count - 1
  lastNonEmptyRow = 0L

  for i=0L,fieldCount-1 do begin
    data.(i) = STRTRIM(data.(i), 2)
    lengths = STRLEN(data.(i))
    good = WHERE(lengths gt 0, ngood)
    if (ngood gt 0) then begin
      firstNonEmptyRow = firstNonEmptyRow &lt; MIN(good)
      lastNonEmptyRow = lastNonEmptyRow > MAX(good)
      columnLen[i] = MAX(lengths)
    endif
  endfor

  nColumns = LONG(TOTAL(columnLen gt 0))
  
  <span class="comments">; All of the fields were empty.</span>
  if (nColumns eq 0) then begin
    return, 0
  endif
  
  count = lastNonEmptyRow - firstNonEmptyRow + 1

  <span class="comments">; Convert each field to a pointer, for easier manipulation.</span>
  j = 0L
  pData = PTRARR(nColumns)
  for i=0L,fieldCount-1 do begin
    if (columnLen[i] eq 0) then continue
    columnLen[j] = columnLen[i]
    pData[j] = PTR_NEW((data.(i))[firstNonEmptyRow:lastNonEmptyRow])
    j++
  endfor
  
  data = 0
  columnLen = columnLen[0:nColumns-1]


  if (count gt 1) then begin
    <span class="comments">; Attempt to determine the data types for each field.</span>
    if (n_elements(types) eq 1) then types=replicate(types,nColumns)
    if (n_elements(types) ne nColumns) then begin
      types = BYTARR(nColumns)
      rowlimit=n_elements(rows_for_testing) eq 1 ? rows_for_testing : 100
      if (rowlimit eq 0) then rowlimit=count-1
      for j=0,nColumns-1 do begin
      
        subdata = (*pData[j])[1:(rowlimit &lt; (count-1))]
        
        ON_IOERROR, skip1
  
        tmpDouble = DOUBLE(subdata)
        tmpLong64 = LONG64(subdata)
        tmpLong = LONG(subdata)
        hasDecimal = MAX(STRPOS(subdata, '.')) ge 0
        isnumber=total(pp_isnumber(subdata,nan=nan,infinity=infinity,integer=integer,trim=trim,blank=blank)) eq n_elements(subdata)
        if ~isnumber then continue
  
        if (hasDecimal || ~ARRAY_EQUAL(tmpLong64, tmpDouble)) then begin
          <span class="comments">; Double</span>
          types[j] = 5
        endif else begin
          <span class="comments">; CR61359: Make sure that our integer data doesn't have any</span>
          <span class="comments">; non-numeric characters. If so, then just return strings instead.</span>
          newLen = STRLEN(STRTRIM(tmpLong64,2))
          origLen = STRLEN(subdata)
          <span class="comments">; Null strings will have been converted to the number zero.</span>
          <span class="comments">; Set their length back to 0.</span>
          newLen[WHERE(origLen eq 0, /NULL)] = 0
          if (~ARRAY_EQUAL(newLen, origLen) || ARRAY_EQUAL(newLen,0)) then continue
          <span class="comments">; Long or Long64</span>
          types[j] = ARRAY_EQUAL(tmpLong, tmpLong64) ? 3 : 14
        endelse
        
  skip1:
        ON_IOERROR, null
        
      endfor
    endif
    
    <span class="comments">; Attempt to determine if the first line is a header line.</span>
    isFirstLineText = 0
    for j=0,nColumns-1 do begin
      if (types[j] ne 0) then begin
        ON_IOERROR, skip2
        <span class="comments">; If we fail to convert the first item to the type for that column,</span>
        <span class="comments">; then assume that it is a "string" column header.</span>
        result = FIX((*pData[j])[0], TYPE=types[j])
        continue
skip2:
        ON_IOERROR, null
        isFirstLineText = 1
        break
      endif
    endfor
    
    nheader = isFirstLineText ? 1 : 0
    
    fieldNames = Read_CSV_Fieldnames(nColumns)
    
    if (nheader gt 0) then begin
      count -= nheader
      header = STRARR(nColumns, nheader)
      for j=0,nColumns-1 do begin
        header[j,*] = (*pData[j])[0:nheader-1]
      endfor
    endif else begin
      <span class="comments">; If NUM_RECORDS was specified, we needed to read one extra record,</span>
      <span class="comments">; in case there was a header. Since there was no header, get rid</span>
      <span class="comments">; of the extra record.</span>
      if (N_Elements(numRecordsIn)) then count--
    endelse
    
    hasMissingValue = N_Elements(missingValue) eq 1 && $
      missingValue[0] ne 0
    
    <span class="comments">; Do the actual type conversion.</span>
    
    for j=0,nColumns-1 do begin
    
      *pData[j] = (*pData[j])[nheader:nheader+count-1]
      
      if (types[j] ne 0) then begin
      
        if (hasMissingValue) then begin
          iMiss = WHERE(*pData[j] eq '', nmiss)
        endif
        
        ON_IOERROR, skip3
        <span class="comments">; Do the actual type conversion.</span>
        *pData[j] = FIX(*pData[j], TYPE=types[j])
        
        if (hasMissingValue && nmiss gt 0) then begin
          (*pData[j])[iMiss] = missingValue[0]
        endif
skip3:
        ON_IOERROR, null
      endif
    endfor
    

  endif   <span class="comments">; count gt 1</span>
  
  
  <span class="comments">; Create the final anonymous structure.</span>
  data = READ_ASCII_CREATE_STRUCT(fieldNames, pData)
  
  PTR_FREE, pData
  
  return, data
end
</code>
    </div>
  </body>
</html>