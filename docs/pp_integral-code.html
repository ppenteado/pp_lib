<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue May 16 12:42:25 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pp_integral.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pp_integral.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Feb/2010</span>
<span class="comments">;-</span>
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Calculates the area under the y(x) curve provided. The function must be ordered in x, but it does not</span>
<span class="comments">;    matter whether the order is increasing or decreasing.</span>
<span class="comments">;    </span>
<span class="comments">;    There are two possible ways that the input function is interpreted, determined by the keyword local.</span>
<span class="comments">;    See the description of local below, since it may significantly alter the result.</span>
<span class="comments">;    </span>
<span class="comments">;    If the method selected requires interpolation, it can be linear, 3 or 4-point quadratic, or spline. This is determined</span>
<span class="comments">;    by setting the quadratic, lsquadratic, or spline keywords (linear if none of these 3 keywords is set).</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    If xmin and xmax are not provided, returns the area under the curve over its whole extension.</span>
<span class="comments">;    </span>
<span class="comments">;    If xmin and xmax are scalars, returns the area between these x values. If they are arrays of n elements,</span>
<span class="comments">;    returns the n areas, calculated starting at each xmin element, and ending at the corresponding xmax element.</span>
<span class="comments">;    </span>
<span class="comments">;    Every value in xmax is must be larger than or equal to the correspoinding value in xmin.</span>
<span class="comments">;     </span>
<span class="comments">; :Params:</span>
<span class="comments">;    x : in, required</span>
<span class="comments">;      An array of locations where the function is sampled. Must be ordered (increasing or decreasing).</span>
<span class="comments">;    y : in, required </span>
<span class="comments">;      An array with the function values corresponding to the locations in x.</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    xmin : in, out, optional</span>
<span class="comments">;      A scalar or array with the start of the range(s) where the area is to be calculated. If not provided,</span>
<span class="comments">;      the minimum location of the function is used. Must have the same number of elements as xmax, and every</span>
<span class="comments">;      element in xmin must be smaller than or equal to the corresponding element in xmax. If any value of xmin</span>
<span class="comments">;      is smaller than the beginning of the x range, it is clipped to the beginning.</span>
<span class="comments">;    xmax : in, out, optional</span>
<span class="comments">;      A scalar or array with the end of the range(s) where the area is to be calculated. If not provided,</span>
<span class="comments">;      the maximum location of the function is used. Must have the same number of elements as xmin, and every</span>
<span class="comments">;      element in xmax must be larger than or equal to the corresponding element in xmin. If any value of xmax</span>
<span class="comments">;      is larger than the end of the x range, it is clipped to the end.</span>
<span class="comments">;    cumulative : in, optional, default=0</span>
<span class="comments">;      If set, and xmin and xmax are not provided, the areas returned are the cumulative areas at the end of each x point,</span>
<span class="comments">;      starting at the first x point. If xmax and xmin are provided, this keyword is ignored.</span>
<span class="comments">;    xinc : out, optional</span>
<span class="comments">;      Returns the x values, in increasing order.</span>
<span class="comments">;    yinc : out, optional</span>
<span class="comments">;      Returns the y values, in order of increasing x.</span>
<span class="comments">;    xstart : out, optional</span>
<span class="comments">;      If local is not set, returns the location where each input pixel starts. If local is set, this is ignored.</span>
<span class="comments">;    xend : out, optional</span>
<span class="comments">;      If local is not set, returns the location where each input pixel ends. If local is set, this is ignored.</span>
<span class="comments">;    xbox : out, optional</span>
<span class="comments">;      Used when not in local mode, to return the input x values in pairs of equal values, so that</span>
<span class="comments">;      plotting xbox,ybox shows the rectangles that are how the input values were interpreted.</span>
<span class="comments">;    ybox : out, optional</span>
<span class="comments">;      Used when not in local mode, to return the input y values in pairs of equal values, so that</span>
<span class="comments">;      plotting xbox,ybox shows the rectangles that are how the input values were interpreted.</span>
<span class="comments">;    newton : in, optional, default=0</span>
<span class="comments">;      If local is set and newton is set, the function integrations are done with int_tabulated, which</span>
<span class="comments">;      uses a 5 point Newton-Cotes formula. If not set, trapezoid integration is done. If local is not set, this has no effect.  </span>
<span class="comments">;    local : in, optional, default=0</span>
<span class="comments">;      Determines how the input function is interpreted, which determines how the areas are calculated. If set, the function is</span>
<span class="comments">;      interpreted literally, that is, as in a simple mathematical function: the y values are the local evaluation y(x).</span>
<span class="comments">;      </span>
<span class="comments">;      If not set, the y values are interpreted as a measured sample, that is, as the average of the "flux" falling inside the region</span>
<span class="comments">;      centered at the corresponding x values: x locations are interpreted as the centers of bins. Since this interpretation is equivalent</span>
<span class="comments">;      to a literal interpretation of a function made of rectangular regions, in this method there are no interpolations (partial areas, if</span>
<span class="comments">;      any, are just the corresponding fractions of the rectangles).</span>
<span class="comments">;    lsquadratic : in, optional, default=0</span>
<span class="comments">;      If the method requires interpolation, this is passed on to interpol, to select 4 point quadratic interpolation.</span>
<span class="comments">;      </span>
<span class="comments">;      If none of lsquadratic, quadratic and spline are set, interpolation is linear. </span>
<span class="comments">;    quadratic : in, optional, default=0</span>
<span class="comments">;      If the method requires interpolation, this is passed on to interpol, to select 3 point quadratic interpolation.</span>
<span class="comments">;      </span>
<span class="comments">;      If none of lsquadratic, quadratic and spline are set, interpolation is linear.</span>
<span class="comments">;    spline : in, optional, default=0</span>
<span class="comments">;      If the method requires interpolation, this is passed on to interpol, to select spline interpolation.</span>
<span class="comments">;      </span>
<span class="comments">;      If none of lsquadratic, quadratic and spline are set, interpolation is linear.</span>
<span class="comments">;      </span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">; </span>
<span class="comments">;   Make up a simple constant function to show the difference between local and non-local modes::</span>
<span class="comments">;   </span>
<span class="comments">;     x=[0d0,1d0]</span>
<span class="comments">;     y=[2d0,2d0]</span>
<span class="comments">;     print,pp_integral(x,y,xmin=xmin,xmax=xmax)</span>
<span class="comments">;     ;4.0000000</span>
<span class="comments">;     print,xmin,xmax</span>
<span class="comments">;     ;-0.50000000       1.5000000</span>
<span class="comments">;     ;(the x locations are considered the middle of the bins, so the bins extend beyond the range min(x),max(x)) </span>
<span class="comments">;     print,pp_integral(x,y,xmin=lxmin,xmax=lxmax,/local)</span>
<span class="comments">;     ;2.0000000</span>
<span class="comments">;     print,lxmin,lxmax</span>
<span class="comments">;     ;0.0000000       1.0000000</span>
<span class="comments">;     </span>
<span class="comments">;   Make up a well sampled function, so that the difference between local and non-local is small::</span>
<span class="comments">;   </span>
<span class="comments">;     x=dindgen(10001)*!dpi/1d4</span>
<span class="comments">;     y=sin(x)</span>
<span class="comments">;     a=pp_integral(x,y,xmin=[0d0,0d0],xmax=!dpi*[0.5d0,1d0])</span>
<span class="comments">;     b=pp_integral(x,y,xmin=[0d0,0d0],xmax=!dpi*[0.5d0,1d0],/local)</span>
<span class="comments">;     print,a</span>
<span class="comments">;     ;1.0003142       2.0000000</span>
<span class="comments">;     print,b</span>
<span class="comments">;     ;1.0000000       2.0000000</span>
<span class="comments">;     print,a-b</span>
<span class="comments">;     ;0.00031410992  -4.9348009e-08</span>
<span class="comments">;     </span>
<span class="comments">;   </span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Feb/2010</span>
<span class="comments">;-</span>
<a id="pp_integral:source"></a>function pp_integral,x,y,xmin=xmin,xmax=xmax,cumulative=cumulative,$
 xinc=ix,yinc=iy,xstart=xstart,xend=xend,xbox=xbox,ybox=ybox,$
 newton=newton,local=local,$
 lsquadratic=lsquadratic,quadratic=quadratic,spline=spline
compile_opt idl2

<span class="comments">;Check that the dimensions of x and y match and are acceptable</span>
nx=n_elements(x) & ny=n_elements(y)
if (nx ne ny) || (nx eq 0) then message,'x and y provided must be arrays of the same length'

<span class="comments">;Check that the dimensions of xmin and xmax match and are acceptable</span>
nxmin=n_elements(xmin) & nxmax=n_elements(xmax)
if (nxmin ne nxmax) then message,'xmin and xmax provided must be arrays of the same length'

<span class="comments">;Defaults</span>
local=n_elements(local) eq 1 ? local : 0
newton=local ? 0 : n_elements(newton) eq 1 ? newton : 0
cumulative=n_elements(cumulative) eq 1 ? cumulative : 0

<span class="comments">;Make ix and iy to work with, 1D and in increasing order (x is assumed sorted, but can be increasing or decreasing order)</span>
if (x[nx-1] lt x[0]) then begin
  ix=reverse(reform(x)) & iy=reverse(reform(y))
endif else begin
  ix=reform(x) & iy=reform(y)
endelse

if (~local) then begin <span class="comments">;Input function is histogram-like (rectangle rule)</span>
  <span class="comments">;Calculate the x start and end points for the tabulated function</span>
  xstart=[ix[0]-(ix[1]-ix[0])/2d0,(ix[0:nx-2]+ix[1:nx-1])/2d0]
  xend=[xstart[1:nx-1],ix[nx-1]+(ix[nx-1]-ix[nx-2])/2d0]
  <span class="comments">;Default interval</span>
  xmin=n_elements(xmin) gt 0 ? xmin : cumulative ? replicate(xstart[0],nx) : xstart[0]
  xmax=n_elements(xmax) gt 0 ? xmax : cumulative ? xend : xend[nx-1]
  <span class="comments">;Clip the edges of the interval if they exceeed the input function's range </span>
  xmin=xstart[0]>xmin&lt;xend[nx-1]
  xmax=xstart[0]>xmax&lt;xend[nx-1]
  nlocs=n_elements(xmin)
  minloc=value_locate(xstart,xmin)
  maxloc=(value_locate(xend,xmax)+1)&lt;(nx-1)
  <span class="comments">;Area of the partial rectangles at the edges</span>
  ret=(xend[minloc]-xmin)*iy[minloc]+(xmax-xend[maxloc])*iy[maxloc]
  <span class="comments">;Area where min and max fall in the same rectangle </span>
  w=where((maxloc-minloc) eq 0L,nw)
  if (nw gt 0L) then ret[w]=(xmax[w]-xmin[w])*iy[maxloc[w]]
  <span class="comments">;Area of the full rectangles contained in the output intervals</span>
  w=where((maxloc-minloc) gt 0L,nw)
  if (nw gt 0L) then begin
    areas=total((xend-xstart)*iy,/cumulative) <span class="comments">;The cumulative area of the rectangles</span>
    ret[w]+=areas[maxloc[w]]-areas[minloc[w]]
  endif
endif else begin <span class="comments">;Input function is interpreted literally</span>
  <span class="comments">;Default interval</span>
  xmin=n_elements(xmin) gt 0 ? xmin : cumulative ? replicate(ix[0],nx) : ix[0]
  xmax=n_elements(xmax) gt 0 ? xmax : cumulative ? ix : ix[nx-1]
  <span class="comments">;Clip the edges of the interval if they exceeed the input function's range</span>
  xmin=ix[0]>xmin&lt;ix[nx-1]
  xmax=ix[0]>xmax&lt;ix[nx-1]
  minloc=value_locate(ix,xmin)
  maxloc=value_locate(ix,xmax)
  ymins=interpol(iy,ix,xmin,lsquadratic=lsquadratic,quadratic=quadratic,spline=spline)
  ymaxs=interpol(iy,ix,xmax,lsquadratic=lsquadratic,quadratic=quadratic,spline=spline)
  if (newton) then begin <span class="comments">;Use int_tabulated, that does a 5 point Newton-Cotes integration</span>
    nlocs=n_elements(xmin)
    ret=dblarr(nlocs)
    for i=0L,nlocs-1 do begin
      xtmp=[xmin[i],ix[minloc[i]:maxloc[i]:minloc[i] le maxloc[i] ? 1L : -1L],xmax[i]]
      ytmp=[ymins[i],iy[minloc[i]:maxloc[i]:minloc[i] le maxloc[i] ? 1L : -1L],ymaxs[i]]
      ret[i]=int_tabulated(xtmp,ytmp,/double)
    endfor
  endif else begin <span class="comments">;Use trapezoidal integration</span>
    <span class="comments">;Area of the partial trapezoids at the edges</span>
    ret=(ix[(minloc+1)&lt;(nx-1)]-xmin)*(ymins+iy[(minloc+1)&lt;(nx-1)])*0.5d0
    w=where(ix[minloc] eq xmin,nw)
<span class="comments">;    if (nw gt 0L) then ret[w]=0d0</span>
    ret+=(xmax-ix[maxloc])*(ymaxs+iy[maxloc])*0.5d0
    <span class="comments">;Area where min and max fall in the same trapezoid </span>
    w=where((maxloc-minloc) eq 0L,nw)
    if (nw gt 0L) then ret[w]=(xmax[w]-xmin[w])*(ymaxs[w]+ymins[w])*0.5d0
    <span class="comments">;Area of the full trapezoids contained in the output intervals</span>
    w=where((maxloc-minloc) gt 1L,nw)
    if (nw gt 0L) then begin
      areas=[0d0,total((ix[1:*]-ix[0:nx-1])*(iy[1:*]+iy[0:nx-1])*0.5d0,/cumulative)] <span class="comments">;The cumulative area of the trapezoids</span>
      ret[w]+=areas[maxloc[w]]-areas[(minloc[w]+1)&lt;(nx-1)]
    endif
  endelse
endelse

<span class="comments">;Create xbox and ybox arrays, with constant y values spanning the start and end of each x point</span>
if (~local && (arg_present(xbox) || arg_present(ybox))) then begin
  nix=n_elements(ix)
  xbox=dblarr(2L*nix) & ybox=dblarr(2L*nix)
  xbox[0:*:2]=xstart & xbox[1:*:2]=xend
  ybox[0:*:2]=iy & ybox[1:*:2]=iy
endif
 
return,ret
end
</code>
    </div>
  </body>
</html>