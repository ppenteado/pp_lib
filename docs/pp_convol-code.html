<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue May 16 12:42:24 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pp_convol.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pp_convol.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Feb/2010</span>
<span class="comments">;-</span>



<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Examples to test and illustrate the different behaviors of pp_convol.</span>
<span class="comments">;    </span>
<span class="comments">;    Makes up a high resolution spectrum and convolves it to lower resolutions.    </span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    width : in, optional, default=0.04</span>
<span class="comments">;      The width for the convolution kernels.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Convolve spectra to different resolutions::</span>
<span class="comments">;    </span>
<span class="comments">;      .com pp_convol ;pp_convol_test is in pp_convol.pro, so it will not be found by itself</span>
<span class="comments">;      pp_convol_test,0.04</span>
<span class="comments">;      pp_convol_test,0.02</span>
<span class="comments">;      </span>
<span class="comments">;   .. image:: pp_convol_test_1.png</span>
<span class="comments">;   .. image:: pp_convol_test_2.png</span>
<span class="comments">;</span>
<span class="comments">; :Uses: pp_resample,pp_integral</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Feb/2010</span>
<span class="comments">;-</span>
<a id="pp_convol_test:source"></a>pro pp_convol_test,width
<span class="comments">;Example and test case for pp_convol</span>
compile_opt idl2

<span class="comments">;Defaults</span>
width=n_elements(width) eq 1 ? width : 0.04

<span class="comments">;Make up a high resolution spectrum and plot it</span>
nx=1001
x=dindgen(nx)/(nx-1d0)
noise=0.005
y=1d0+randomu(seed,nx,/normal)*noise
nlines=30
df=0.7d0
depths=(randomu(seed,nlines)-0.5d0)*df
wf=0.025
widths=randomu(seed,nlines)*wf
centers=randomu(seed,nlines)
for i=0,nlines-1 do y+=depths[i]*exp(-((x-centers[i])/widths[i])^2)
iplot,x,y,name='Original spectrum',/insert_legend,$
 title='Original at '+strtrim(string(x[1]-x[0]),2)+', convolved to '+strtrim(string(width),2)
<span class="comments">;Convolve with Gaussians at lower resolution</span>
yc0=pp_convol(y,x,/gaussian,width=width,/local)
iplot,x,yc0,/over,color=[255,0,0],name='Gaussian (literal)',/insert_legend
yc0=pp_convol(y,x,/gaussian,width=width)
iplot,x,yc0,/over,color=[0,0,255],name='Gaussian (sampled)',/insert_legend
yc0=pp_convol(y,x,/step,width=width,/local)
<span class="comments">;Convolve with rectangular kernels at lower resolution</span>
iplot,x,yc0,/over,color=[0,255,0],name='Step (literal)',/insert_legend
yc0=pp_convol(y,x,/step,width=width)
iplot,x,yc0,/over,color=[255,0,255],name='Step (sampled)',/insert_legend

end



<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Convolves the provided y(x) function with either a rectangular or Gaussian</span>
<span class="comments">;    kernel of the given width, or the provided arbitrary kernel (not yet implemented).</span>
<span class="comments">;    </span>
<span class="comments">;    The x grid does not need to be regular, and, contrary to common practice, no resampling</span>
<span class="comments">;    is done to a regular grid to calculate the convolution (resampling is not needed). Also</span>
<span class="comments">;    contrary to common practice, for rectangular or Gaussian kernels the integral is done</span>
<span class="comments">;    analytically, not numerically. In the case of a Gaussian kernel, it extends from the Gaussian</span>
<span class="comments">;    center up to the point where the terms in the integral become 0 (at double precision).</span>
<span class="comments">;    </span>
<span class="comments">;    Also, this routine allows for both literal and sampled interpretations of the input function (set</span>
<span class="comments">;    with the local keyword). </span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    The result of the convultion is given for the same x locations as the input,</span>
<span class="comments">;    there is no automatic resampling. If resampling is intended after the convolution,</span>
<span class="comments">;    pp_resampled is recommended, as it preserves the areas. </span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    x : in, required</span>
<span class="comments">;      An array of locations where the function is sampled. Must be ordered (increasing or decreasing).</span>
<span class="comments">;    y : in, required </span>
<span class="comments">;      An array with the function values corresponding to the locations in x.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    step : in, optional, default=1</span>
<span class="comments">;      If set, the convolution kernel is a rectangular function of the given width.</span>
<span class="comments">;    gaussian : in, optional, default=0 </span>
<span class="comments">;      If set, the convolution kernel is a Gaussian, of fwhm of the given width.</span>
<span class="comments">;    width : in, required</span>
<span class="comments">;      The width of the convolution kernel (for step or gaussian).</span>
<span class="comments">;    grid_tolerance : in, optional,default=1d-6</span>
<span class="comments">;      Not yet implemented. Specifies the maximum fractional variation in the input grid to accept it as uniform.</span>
<span class="comments">;      </span>
<span class="comments">;      If the input grid is found to be uniform, the integration can be done faster.</span>
<span class="comments">;    kernelx : in, optional</span>
<span class="comments">;      Not yet implemented. An array of the x locations (centered at x=0) of the arbitrary convolution kernel to use.</span>
<span class="comments">;      </span>
<span class="comments">;      Must be ordered in increasing x.</span>
<span class="comments">;    kernely : in, optional</span>
<span class="comments">;      Not yet implemented. An array of the the arbitrary convolution kernel's values to use.</span>
<span class="comments">;      Must make a function of unit area.</span>
<span class="comments">;    local : in, optional, default=0</span>
<span class="comments">;      If not set, the y values are interpreted as a measured sample, that is, as the average of the "flux" falling inside the region</span>
<span class="comments">;      centered at the corresponding x values: x locations are interpreted as the centers of bins. Since this interpretation is equivalent</span>
<span class="comments">;      to a literal interpretation of a function made of rectangular regions, in this method there are no interpolations (partial areas, if</span>
<span class="comments">;      any, are just the corresponding fractions of the rectangles).</span>
<span class="comments">;      </span>
<span class="comments">;      If set, interprets the input function literally.  </span>
<span class="comments">;    newton : in, optional, default=0</span>
<span class="comments">;      Passed on to pp_integral. If local is set and newton is set, the function integrations are done with int_tabulated, which</span>
<span class="comments">;      uses a 5 point Newton-Cotes formula. If local is not set, this has no effect.</span>
<span class="comments">;    lsquadratic : in, optional, default=0</span>
<span class="comments">;      Passed on to pp_integral. If the method requires interpolation, this is passed on to interpol,</span>
<span class="comments">;      to select 4 point quadratic interpolation.</span>
<span class="comments">;      </span>
<span class="comments">;      If none of lsquadratic, quadratic and spline are set, interpolation is linear. </span>
<span class="comments">;    quadratic : in, optional, default=0</span>
<span class="comments">;      Passed on to pp_integral. If the method requires interpolation, this is passed on to interpol,</span>
<span class="comments">;      to select 3 point quadratic interpolation.</span>
<span class="comments">;      </span>
<span class="comments">;      If none of lsquadratic, quadratic and spline are set, interpolation is linear.</span>
<span class="comments">;    spline : in, optional, default=0</span>
<span class="comments">;      Passed on to pp_integral. If the method requires interpolation, this is passed on to interpol,</span>
<span class="comments">;      to select spline interpolation.</span>
<span class="comments">;      </span>
<span class="comments">;      If none of lsquadratic, quadratic and spline are set, interpolation is linear.</span>
<span class="comments">;    xinc : out, optional</span>
<span class="comments">;      Returns the x values, in increasing order.</span>
<span class="comments">;    yinc : out, optional</span>
<span class="comments">;      Returns the y values, in order of increasing x.</span>
<span class="comments">;    xstart : out, optional</span>
<span class="comments">;      If local is not set, returns the location where each input pixel starts. If local is set, this is ignored.</span>
<span class="comments">;    xend : out, optional</span>
<span class="comments">;      If local is not set, returns the location where each input pixel ends. If local is set, this is ignored.</span>
<span class="comments">;    xbox : out, optional</span>
<span class="comments">;      Used when not in local mode, to return the input x values in pairs of equal values, so that</span>
<span class="comments">;      plotting xbox,ybox shows the rectangles that are how the input values were interpreted.</span>
<span class="comments">;    ybox : out, optional</span>
<span class="comments">;      Used when not in local mode, to return the input y values in pairs of equal values, so that</span>
<span class="comments">;      plotting xbox,ybox shows the rectangles that are how the input values were interpreted.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    </span>
<span class="comments">;   Make a well-sampled input function y(x) with fwhm=1::</span>
<span class="comments">;   </span>
<span class="comments">;     x=(12d0*dindgen(1001)/1d3)-6d0</span>
<span class="comments">;     y=exp(-(x^2*4d0*alog(2d0)))*8d0</span>
<span class="comments">;     iplot,x,y,/isotropic,name='Original function of fwhm=1',/insert_legend,thick=2.</span>
<span class="comments">;</span>
<span class="comments">;   Do the convolution and look at the results::</span>
<span class="comments">;</span>
<span class="comments">;     yc1=pp_convol(y,x,/step,width=4d0)</span>
<span class="comments">;     iplot,x,yc1,/over,color=[255,0,0],name='Convolution width=4, rectangular kernel (sampled)',/insert_legend</span>
<span class="comments">;     yc2=pp_convol(y,x,/step,/local,width=4d0)</span>
<span class="comments">;     iplot,x,yc2,/over,color=[0,0,255],name='Convolution width=4, rectangular kernel (literal)',/insert_legend</span>
<span class="comments">;     yc3=pp_convol(y,x,/gaussian,width=4d0)</span>
<span class="comments">;     iplot,x,yc3,/over,color=[0,255,0],name='Convolution width=4, Gaussian kernel (sampled)',/insert_legend</span>
<span class="comments">;     yc4=pp_convol(y,x,/gaussian,width=4d0,/local)</span>
<span class="comments">;     iplot,x,yc4,/over,color=[255,0,255],name='Convolution width=4, Gaussian kernel (literal)',/insert_legend</span>
<span class="comments">;   </span>
<span class="comments">;   .. image:: pp_convol.png</span>
<span class="comments">;    </span>
<span class="comments">;   See also the example in pp_convol_test, for a comparison of the methods with a more realistic (spectrum-like) function.</span>
<span class="comments">; </span>
<span class="comments">; :Todo: Implement arbitrary kernel, grid_tolerance, and quadratic and cubic Gaussian integrations.</span>
<span class="comments">;</span>
<span class="comments">; :Uses: pp_resample,pp_integral</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Feb/2010</span>
<span class="comments">;-</span>
<a id="pp_convol:source"></a>function pp_convol,y,x,step=step,gaussian=gaus,width=width,grid_tolerance=gtol,$
 kernelx=kx,kernely=ky,$
 local=local,newton=newton,$
 lsquadratic=lsquadratic,quadratic=quadratic,spline=spline,$
 xinc=ix,yinc=iy,xstart=xstart,xend=xend,xbox=xbox,ybox=ybox
compile_opt idl2

<span class="comments">;Defaults</span>
local=n_elements(local) eq 1 ? local : 0
step=n_elements(step) eq 1 ? step : 1
gaus=n_elements(gaus) eq 1 ? gaus : 0
nkx=n_elements(kx) & nky=n_elements(ky)
usekernel=((nkx eq nky) && (nkx gt 0L)) ? 1 : 0
if (gaus) then begin
  step=0
  usekernel=0
endif
if (usekernel) then begin
  step=0
  gaus=0
endif
gtol=n_elements(gtol) eq 1 ? gtol : 1d-6

<span class="comments">;Check that the dimensions of x and y match and are acceptable</span>
nx=n_elements(x) & ny=n_elements(y)
if (nx ne ny) || (nx eq 0) then message,'x and y provided must be arrays of the same length'

<span class="comments">;Make ix and iy to work with, 1D and in increasing order (x is assumed sorted, but can be increasing or decreasing order)</span>
if (x[nx-1] lt x[0]) then begin
  ix=reverse(reform(x)) & iy=reverse(reform(y))
endif else begin
  ix=reform(x) & iy=reform(y)
endelse

<span class="comments">;Determine whether the input grid is regular</span>
dmax=max(ix[1:*]-ix[0:nx-2],/abs,min=dmin)
regular=((dmax-dmin)/dmin le gtol) 

if (step) then begin <span class="comments">;Use a constant function as the kernel</span>
  <span class="comments">;Calculate the locations of the start and end of the interval that will go into each output point</span>
  xmin=x-width/2d0
  xmax=x+width/2d0
  <span class="comments">;Calculate the input function's integral over the proper regions</span>
  areas=pp_integral(x,y,xmin=xmin,xmax=xmax,newton=newton,local=local,$
   lsquadratic=lsquadratic,quadratic=quadratic,spline=spline)
  ret=areas/width
endif

if (gaus) then begin <span class="comments">;Use a Gaussian function as the kernel</span>
  maxwid1=27.3d0 <span class="comments">;In double precision, exp(-x^2) underflows between x=27.29d0 and x=27.3d0</span>
  maxwid0=8.27d0 <span class="comments">;In double precision, gauss_pdf(x) saturates (becomes 1d0) between x=8.26d0 and x=8.27d0</span>
  <span class="comments">;maxwid0=5.888d0 ;In double precision, erf(x) saturates (becomes 1d0) between x=5.8870 and x=5.888d0</span>
  a=width^2/(4d0*alog(2d0)) <span class="comments">;The constant that will go into the exponential (exp(-x^2/a))</span>
  g=1d0/sqrt(a*!dpi) <span class="comments">;Constant that multiplies the exponential in the Gaussian (g*exp(-x^2/a))</span>
  wid0=sqrt(a/2d0)*maxwid0
  wid1=sqrt(a/2d0)*maxwid1
  <span class="comments">;Calculate the integral</span>
  <span class="comments">;This is not numerical integration: it is analytical integration of a function made of a finite number of pieces</span>
  if (local) then begin <span class="comments">;Literal interpretation of the function</span>
    <span class="comments">;Calculate the locations of the start and end of the interval that will go into each output point</span>
    minloc1=(value_locate(ix,ix-wid1))>0L
    maxloc1=(value_locate(ix,ix+wid1)+1L)&lt;(nx-2L) 
    minloc0=(value_locate(ix,ix-wid0))>0L
    maxloc0=(value_locate(ix,ix+wid0)+1L)&lt;(nx-2L)
    <span class="comments">;The integral is of y(x)*g(x-x0)*dx, with y(x)=c0+c1*x</span>
    <span class="comments">;Terms to calculate c0 and c1, coefficients of y(x)=c0+c1*x</span>
    y1=iy[1:nx-1] & y0=iy[0:nx-2] & x1=ix[1:nx-1] & x0=ix[0:nx-2]
    c0=(y0*x1-y1*x0)/(x1-x0)
    c1=(y1-y0)/(x1-x0)
    <span class="comments">;Integral of the first term (c0*g(x-x0)*dx)</span>
    w=where((maxloc0 gt minloc0),nw)
    ret0=dblarr(nx)
    for i=0,nw-1 do begin
      j=w[i]
      xl=ix[j]
      rng=lindgen(maxloc0[j]-minloc0[j]+1)+minloc0[j]
      x0l=(x0[rng]-xl)/sqrt(a)
      x1l=(x1[rng]-xl)/sqrt(a)
      d=(c0+c1*xl)[rng]
      ret0[j]=total(d*(erf(x1l)-erf(x0l)))
      <span class="comments">;ret0[j]+=total(d*(gauss_pdf(x1l)-gauss_pdf(x0l)))</span>
    endfor
    <span class="comments">;Integral of the second term (c1*x*g(x-x0)*dx)</span>
    w=where((maxloc1 gt minloc1),nw)
    ret1=dblarr(nx)  
    for i=0,nw-1 do begin
      j=w[i]
      xl=ix[j]
      rng=lindgen(maxloc1[j]-minloc1[j]+1)+minloc1[j]
      x0l=(x0[rng]-xl)/sqrt(a)
      x1l=(x1[rng]-xl)/sqrt(a)
      ret1[j]+=total(c1[rng]*(exp(-x0l^2)-exp(-x1l^2)))
    endfor
    ret=g*0.5d0*(sqrt(!dpi*a)*ret0+a*ret1)
    <span class="comments">;ret=g*(ret0+0.5d0*a*ret1)</span>
  endif else begin
    <span class="comments">;Calculate the locations of the start and end of the interval that will go into each output point</span>
    xstart=[ix[0]-(ix[1]-ix[0])/2d0,(ix[0:nx-2]+ix[1:nx-1])/2d0]
    xend=[xstart[1:nx-1],ix[nx-1]+(ix[nx-1]-ix[nx-2])/2d0]
    minloc0=(value_locate(xstart,xstart-wid0))>0L
    maxloc0=(value_locate(xend,xend+wid0)+1L)&lt;(nx-1L)
    <span class="comments">;The integral is of y(x)*g(x-x0)*dx, with y(x)=c0</span>
    xsig=ix/sqrt(a/2d0) <span class="comments">;x normalized by the Gaussian standard deviation</span>
    xstartsig=xstart/sqrt(a/2d0) <span class="comments">;x normalized by the Gaussian standard deviation</span>
    xendsig=xend/sqrt(a/2d0) <span class="comments">;x normalized by the Gaussian standard deviation</span>
    w=where((maxloc0 gt minloc0),nw)
    ret=dblarr(nx)
    for i=0L,nw-1 do begin
      j=w[i]
      ret[j]+=total(iy[minloc0[j]:maxloc0[j]]*(gauss_pdf(xendsig[minloc0[j]:maxloc0[j]]-xsig[j])-gauss_pdf(xstartsig[minloc0[j]:maxloc0[j]]-xsig[j])))
    endfor  
  endelse
endif

if (~local) then begin
  <span class="comments">;Calculate the start and en of each output point</span>
  xstart=[ix[0]-(ix[1]-ix[0])/2d0,(ix[0:nx-2]+ix[1:nx-1])/2d0]
  xend=[xstart[1:nx-1],ix[nx-1]+(ix[nx-1]-ix[nx-2])/2d0]
<span class="comments">;Create xbox and ybox arrays, with constant y values spanning the start and end of each x point</span>
  if (arg_present(xbox) || arg_present(ybox)) then begin
    nix=n_elements(ix)
    xbox=dblarr(2L*nix) & ybox=dblarr(2L*nix)
    xbox[0:*:2]=xstart & xbox[1:*:2]=xend
    ybox[0:*:2]=iy & ybox[1:*:2]=iy
  endif
endif

return,ret
end
</code>
    </div>
  </body>
</html>